{"version":3,"file":"three-presenter.js","sources":["../src/managers/AnnotationManager.ts","../src/types/FileUrlResolver.ts","../src/utils/GeometryUtils.ts","../src/ui/UIControlsBuilder.ts","../src/managers/CameraManager.ts","../src/managers/LightingManager.ts","../src/managers/ModelLoader.ts","../src/ThreePresenter.ts"],"sourcesContent":["/**\n * AnnotationManager - Independent annotation rendering and selection system\n * \n * This module manages 3D annotation markers in a Three.js scene.\n * It handles rendering, selection, screen-space sizing, and picking mode.\n * \n * Features:\n * - Render annotations as 3D spheres\n * - Multi-select support (Ctrl/Cmd + click)\n * - Screen-space consistent sizing (perspective & orthographic)\n * - Picking mode for creating new annotations\n * - Visual feedback for selection state\n * \n * @example\n * ```typescript\n * const manager = new AnnotationManager(scene, {\n *   color: 0xffff00,\n *   selectedColor: 0xffff66,\n *   markerSize: 10\n * });\n * \n * manager.render(annotations);\n * manager.select(['id1', 'id2'], false);\n * manager.onSelectionChange((ids) => console.log('Selected:', ids));\n * ```\n */\n\nimport * as THREE from 'three';\nimport type {\n  Annotation,\n  AnnotationConfig,\n  SelectionChangeCallback,\n  PointPickedCallback\n} from '../types/AnnotationTypes';\n\n/**\n * Default configuration for annotation rendering\n */\nconst DEFAULT_CONFIG: Required<AnnotationConfig> = {\n  color: 0xffff00,           // Yellow\n  selectedColor: 0xffff66,   // Brighter yellow\n  opacity: 0.9,              // Slightly transparent\n  selectedOpacity: 1.0,      // Fully opaque\n  markerSize: 10,            // 10 pixels\n  sphereSegments: 16         // Good balance of quality/performance\n};\n\n/**\n * AnnotationManager - Manages annotation markers in a Three.js scene\n */\nexport class AnnotationManager {\n  private scene: THREE.Scene;\n  private config: Required<AnnotationConfig>;\n  \n  // Annotation state\n  private markers: Map<string, THREE.Mesh> = new Map();\n  private selectedIds: Set<string> = new Set();\n  private annotations: Annotation[] = [];\n  \n  // Callbacks\n  private selectionCallbacks: SelectionChangeCallback[] = [];\n  private pickCallback: PointPickedCallback | null = null;\n  \n  /**\n   * Create a new AnnotationManager\n   * @param scene - The Three.js scene to add markers to\n   * @param config - Optional configuration for appearance and behavior\n   */\n  constructor(scene: THREE.Scene, config: AnnotationConfig = {}) {\n    this.scene = scene;\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Render annotations as 3D markers in the scene\n   * @param annotations - Array of annotations to render\n   */\n  render(annotations: Annotation[]): void {\n    this.annotations = annotations;\n    \n    // Remove markers that no longer exist\n    const currentIds = new Set(annotations.map(a => a.id));\n    for (const [id, marker] of this.markers.entries()) {\n      if (!currentIds.has(id)) {\n        this.removeMarker(id);\n      }\n    }\n\n    // Add or update markers\n    annotations.forEach(annotation => {\n      // Only handle point annotations for now\n      if (annotation.type !== 'point') return;\n      \n      const geometry = annotation.geometry as [number, number, number];\n      const position = new THREE.Vector3(geometry[0], geometry[1], geometry[2]);\n      \n      let marker = this.markers.get(annotation.id);\n      const isSelected = this.selectedIds.has(annotation.id);\n      \n      if (marker) {\n        // Update existing marker\n        marker.position.copy(position);\n        this.updateMarkerAppearance(marker, isSelected);\n      } else {\n        // Create new marker\n        marker = this.createMarker(position, isSelected);\n        this.markers.set(annotation.id, marker);\n        this.scene.add(marker);\n      }\n    });\n\n    console.log(`üéØ AnnotationManager: Rendered ${annotations.length} annotation(s)`);\n  }\n\n  /**\n   * Select one or more annotations\n   * @param ids - Array of annotation IDs to select\n   * @param additive - If true, add to selection; if false, replace selection\n   */\n  select(ids: string[], additive: boolean = false): void {\n    if (!additive) {\n      this.selectedIds.clear();\n    }\n    \n    ids.forEach(id => this.selectedIds.add(id));\n    this.updateAllMarkerAppearances();\n    this.notifySelectionChange();\n    \n    console.log(`‚úÖ AnnotationManager: Selected ${ids.length} annotation(s) (total: ${this.selectedIds.size})`);\n  }\n\n  /**\n   * Toggle selection state of an annotation\n   * @param id - Annotation ID to toggle\n   */\n  toggleSelection(id: string): void {\n    if (this.selectedIds.has(id)) {\n      this.selectedIds.delete(id);\n      console.log(`‚ùå AnnotationManager: Deselected ${id}`);\n    } else {\n      this.selectedIds.add(id);\n      console.log(`‚úÖ AnnotationManager: Selected ${id}`);\n    }\n    \n    this.updateAllMarkerAppearances();\n    this.notifySelectionChange();\n  }\n\n  /**\n   * Clear all selections\n   */\n  clearSelection(): void {\n    if (this.selectedIds.size > 0) {\n      this.selectedIds.clear();\n      this.updateAllMarkerAppearances();\n      this.notifySelectionChange();\n      console.log('üóëÔ∏è AnnotationManager: Cleared selection');\n    }\n  }\n\n  /**\n   * Get array of selected annotation IDs\n   */\n  getSelected(): string[] {\n    return Array.from(this.selectedIds);\n  }\n\n  /**\n   * Check if an annotation is selected\n   */\n  isSelected(id: string): boolean {\n    return this.selectedIds.has(id);\n  }\n\n  /**\n   * Update marker scales for consistent screen-space size\n   * Should be called in the render loop\n   * @param camera - Current camera (perspective or orthographic)\n   * @param canvasHeight - Height of the canvas in pixels\n   */\n  updateMarkerScales(camera: THREE.Camera, canvasHeight: number): void {\n    const pixelSize = this.config.markerSize;\n    \n    for (const marker of this.markers.values()) {\n      let scale: number;\n      \n      if (camera instanceof THREE.PerspectiveCamera) {\n        // Perspective: scale based on distance and FOV\n        const distance = camera.position.distanceTo(marker.position);\n        const fovRadians = camera.fov * Math.PI / 180;\n        scale = distance * Math.tan(fovRadians / 2) * 2 * pixelSize / canvasHeight;\n      } else if (camera instanceof THREE.OrthographicCamera) {\n        // Orthographic: scale based on frustum size (no perspective)\n        const visibleHeight = camera.top - camera.bottom;\n        scale = visibleHeight * pixelSize / canvasHeight;\n      } else {\n        // Fallback for unknown camera types\n        scale = 0.01;\n      }\n      \n      marker.scale.set(scale, scale, scale);\n    }\n  }\n\n  /**\n   * Get the marker mesh for an annotation (for raycasting)\n   */\n  getMarker(id: string): THREE.Mesh | undefined {\n    return this.markers.get(id);\n  }\n\n  /**\n   * Get all marker meshes (for raycasting)\n   */\n  getAllMarkers(): THREE.Mesh[] {\n    return Array.from(this.markers.values());\n  }\n\n  /**\n   * Find annotation ID from a marker mesh\n   */\n  getAnnotationIdFromMarker(marker: THREE.Mesh): string | null {\n    for (const [id, mesh] of this.markers.entries()) {\n      if (mesh === marker) return id;\n    }\n    return null;\n  }\n\n  /**\n   * Register a callback for selection changes\n   * @param callback - Function to call when selection changes\n   * @returns Unsubscribe function\n   */\n  onSelectionChange(callback: SelectionChangeCallback): () => void {\n    this.selectionCallbacks.push(callback);\n    return () => {\n      const index = this.selectionCallbacks.indexOf(callback);\n      if (index > -1) {\n        this.selectionCallbacks.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Enable picking mode for creating new annotations\n   * @param callback - Function to call when a point is picked\n   */\n  enablePicking(callback: PointPickedCallback): void {\n    this.pickCallback = callback;\n    console.log('‚úèÔ∏è AnnotationManager: Picking mode enabled');\n  }\n\n  /**\n   * Disable picking mode\n   */\n  disablePicking(): void {\n    this.pickCallback = null;\n    console.log('‚úèÔ∏è AnnotationManager: Picking mode disabled');\n  }\n\n  /**\n   * Check if picking mode is active\n   */\n  isPickingMode(): boolean {\n    return this.pickCallback !== null;\n  }\n\n  /**\n   * Notify picking callback with a point\n   * @param point - 3D point coordinates\n   */\n  notifyPointPicked(point: [number, number, number]): void {\n    if (this.pickCallback) {\n      this.pickCallback(point);\n      console.log('üìç AnnotationManager: Point picked:', point);\n    }\n  }\n\n  /**\n   * Update configuration\n   * @param config - Partial configuration to merge with current config\n   */\n  updateConfig(config: Partial<AnnotationConfig>): void {\n    this.config = { ...this.config, ...config };\n    this.updateAllMarkerAppearances();\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Required<AnnotationConfig> {\n    return { ...this.config };\n  }\n\n  /**\n   * Dispose of all resources\n   */\n  dispose(): void {\n    // Remove all markers from scene\n    for (const [id, marker] of this.markers.entries()) {\n      this.removeMarker(id);\n    }\n    \n    // Clear callbacks\n    this.selectionCallbacks = [];\n    this.pickCallback = null;\n    \n    console.log('üóëÔ∏è AnnotationManager: Disposed');\n  }\n\n  // ==================== Private Methods ====================\n\n  /**\n   * Create a new marker mesh\n   */\n  private createMarker(position: THREE.Vector3, isSelected: boolean): THREE.Mesh {\n    const geometry = new THREE.SphereGeometry(1.0, this.config.sphereSegments, this.config.sphereSegments);\n    const material = new THREE.MeshBasicMaterial({\n      color: isSelected ? this.config.selectedColor : this.config.color,\n      transparent: true,\n      opacity: isSelected ? this.config.selectedOpacity : this.config.opacity,\n      depthTest: true,\n      depthWrite: true\n    });\n    \n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.position.copy(position);\n    \n    return mesh;\n  }\n\n  /**\n   * Update a marker's appearance based on selection state\n   */\n  private updateMarkerAppearance(marker: THREE.Mesh, isSelected: boolean): void {\n    const material = marker.material as THREE.MeshBasicMaterial;\n    material.color.setHex(isSelected ? this.config.selectedColor : this.config.color);\n    material.opacity = isSelected ? this.config.selectedOpacity : this.config.opacity;\n  }\n\n  /**\n   * Update all markers' appearances based on current selection\n   */\n  private updateAllMarkerAppearances(): void {\n    for (const [id, marker] of this.markers.entries()) {\n      const isSelected = this.selectedIds.has(id);\n      this.updateMarkerAppearance(marker, isSelected);\n    }\n  }\n\n  /**\n   * Remove a marker from the scene\n   */\n  private removeMarker(id: string): void {\n    const marker = this.markers.get(id);\n    if (marker) {\n      this.scene.remove(marker);\n      marker.geometry.dispose();\n      (marker.material as THREE.Material).dispose();\n      this.markers.delete(id);\n    }\n  }\n\n  /**\n   * Notify all selection change callbacks\n   */\n  private notifySelectionChange(): void {\n    const selectedIds = this.getSelected();\n    this.selectionCallbacks.forEach(callback => {\n      try {\n        callback(selectedIds);\n      } catch (error) {\n        console.error('Error in selection change callback:', error);\n      }\n    });\n  }\n}\n","/**\n * File URL Resolver Interface\n * \n * Provides a clean abstraction for resolving file URLs from relative paths.\n * This makes ThreePresenter independent of any specific API or configuration system.\n * \n * @module FileUrlResolver\n */\n\n/**\n * Context information needed to resolve a file URL\n */\nexport interface FileResolverContext {\n  /** Project identifier (if applicable) */\n  projectId?: string;\n  \n  /** Scene identifier (if applicable) */\n  sceneId?: string;\n  \n  /** Additional context data */\n  [key: string]: any;\n}\n\n/**\n * Interface for resolving file URLs\n * \n * Implementations can provide different strategies:\n * - OCRA API resolver (uses backend API)\n * - Static file resolver (uses local/CDN paths)\n * - Custom resolver (user-defined logic)\n */\nexport interface FileUrlResolver {\n  /**\n   * Resolve a file path to a full URL\n   * \n   * @param filePath - The file path to resolve (can be relative or absolute)\n   * @param context - Additional context for resolution (e.g., projectId)\n   * @returns The full URL to load the file from\n   * \n   * @example\n   * ```typescript\n   * // Relative path\n   * const url = resolver.resolve('model.glb', { projectId: '123' });\n   * // => 'http://localhost:3000/api/projects/123/files/model.glb'\n   * \n   * // Absolute path (pass through)\n   * const url = resolver.resolve('http://example.com/model.glb', {});\n   * // => 'http://example.com/model.glb'\n   * ```\n   */\n  resolve(filePath: string, context: FileResolverContext): string;\n}\n\n/**\n * Default file URL resolver\n * \n * Simple implementation that:\n * - Returns absolute URLs unchanged\n * - Returns relative URLs unchanged (assumes they're relative to the current page)\n * \n * Useful for:\n * - Loading files from the same origin\n * - Development/testing\n * - Simple deployments where files are co-located\n */\nexport class DefaultFileUrlResolver implements FileUrlResolver {\n  resolve(filePath: string, context: FileResolverContext): string {\n    // If already absolute URL, return as-is\n    if (filePath.startsWith('http://') || filePath.startsWith('https://')) {\n      return filePath;\n    }\n    \n    // Return relative path unchanged (browser will resolve relative to current page)\n    return filePath;\n  }\n}\n\n/**\n * Static base URL resolver\n * \n * Prepends a base URL to relative paths.\n * Useful for CDN or static file hosting.\n * \n * @example\n * ```typescript\n * const resolver = new StaticBaseUrlResolver('https://cdn.example.com/models');\n * const url = resolver.resolve('scene.glb', {});\n * // => 'https://cdn.example.com/models/scene.glb'\n * ```\n */\nexport class StaticBaseUrlResolver implements FileUrlResolver {\n  constructor(private baseUrl: string) {\n    // Remove trailing slash for consistency\n    this.baseUrl = baseUrl.replace(/\\/$/, '');\n  }\n\n  resolve(filePath: string, context: FileResolverContext): string {\n    // If already absolute URL, return as-is\n    if (filePath.startsWith('http://') || filePath.startsWith('https://')) {\n      return filePath;\n    }\n    \n    // Remove leading slash from filePath if present\n    const cleanPath = filePath.startsWith('/') ? filePath.slice(1) : filePath;\n    \n    return `${this.baseUrl}/${cleanPath}`;\n  }\n}\n\n/**\n * Function-based resolver\n * \n * Wraps a custom resolution function as a FileUrlResolver.\n * Most flexible option for custom logic.\n * \n * @example\n * ```typescript\n * const resolver = new FunctionResolver((path, ctx) => {\n *   if (path.startsWith('http')) return path;\n *   return `https://api.example.com/files/${ctx.projectId}/${path}`;\n * });\n * ```\n */\nexport class FunctionResolver implements FileUrlResolver {\n  constructor(\n    private resolveFn: (filePath: string, context: FileResolverContext) => string\n  ) {}\n\n  resolve(filePath: string, context: FileResolverContext): string {\n    return this.resolveFn(filePath, context);\n  }\n}\n","/**\n * Geometry Statistics and Utilities\n * \n * Pure utility functions for analyzing and calculating Three.js geometry properties.\n * All functions are stateless and side-effect free, making them easy to test and reuse.\n * \n * @module GeometryUtils\n */\n\nimport * as THREE from 'three';\n\n/**\n * Statistics about a 3D object's geometry\n */\nexport interface GeometryStats {\n  /** Total number of triangles (faces) */\n  triangles: number;\n  \n  /** Total number of vertices */\n  vertices: number;\n  \n  /** Bounding box dimensions */\n  bbox: {\n    x: number;\n    y: number;\n    z: number;\n  };\n  \n  /** Texture information */\n  textures: {\n    count: number;\n    dimensions: Array<{ width: number; height: number }>;\n  };\n}\n\n/**\n * Calculate comprehensive statistics for a 3D object\n * \n * Traverses the object hierarchy and collects:\n * - Triangle/face count\n * - Vertex count\n * - Bounding box dimensions\n * - Texture information\n * \n * @param obj - The Three.js object to analyze\n * @returns Statistics object with geometry information\n * \n * @example\n * ```typescript\n * const stats = calculateObjectStats(model);\n * console.log(`Model has ${stats.triangles} triangles and ${stats.vertices} vertices`);\n * console.log(`Size: ${stats.bbox.x} x ${stats.bbox.y} x ${stats.bbox.z}`);\n * ```\n */\nexport function calculateObjectStats(obj: THREE.Object3D): GeometryStats {\n  let triangles = 0;\n  let vertices = 0;\n  const textureSet = new Set<THREE.Texture>();\n\n  obj.traverse((child) => {\n    if ((child as THREE.Mesh).isMesh) {\n      const mesh = child as THREE.Mesh;\n      const geometry = mesh.geometry;\n      \n      if (geometry) {\n        // Count vertices\n        const positionAttribute = geometry.getAttribute('position');\n        if (positionAttribute) {\n          vertices += positionAttribute.count;\n        }\n\n        // Count triangles\n        if (geometry.index) {\n          // Indexed geometry\n          triangles += geometry.index.count / 3;\n        } else if (positionAttribute) {\n          // Non-indexed geometry\n          triangles += positionAttribute.count / 3;\n        }\n      }\n\n      // Collect textures from materials\n      if (mesh.material) {\n        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach((material: THREE.Material) => {\n          // Check all common texture properties\n          const matAny = material as any;\n          const textureProps = [\n            'map', 'normalMap', 'roughnessMap', 'metalnessMap', \n            'aoMap', 'emissiveMap', 'bumpMap', 'displacementMap', \n            'alphaMap', 'lightMap', 'envMap'\n          ];\n          \n          textureProps.forEach(prop => {\n            if (matAny[prop] && matAny[prop] instanceof THREE.Texture) {\n              textureSet.add(matAny[prop]);\n            }\n          });\n        });\n      }\n    }\n  });\n\n  // Collect texture dimensions\n  const textureDimensions: Array<{ width: number; height: number }> = [];\n  textureSet.forEach(texture => {\n    if (texture.image) {\n      const width = texture.image.width || 0;\n      const height = texture.image.height || 0;\n      textureDimensions.push({ width, height });\n    }\n  });\n\n  // Calculate bounding box dimensions\n  const bbox = new THREE.Box3().setFromObject(obj);\n  const size = bbox.getSize(new THREE.Vector3());\n\n  return { \n    triangles: Math.floor(triangles), \n    vertices,\n    bbox: {\n      x: size.x,\n      y: size.y,\n      z: size.z\n    },\n    textures: {\n      count: textureSet.size,\n      dimensions: textureDimensions\n    }\n  };\n}\n\n/**\n * Calculate the bounding box for an array of objects\n * \n * @param objects - Array of Three.js objects\n * @returns Combined bounding box containing all objects\n * \n * @example\n * ```typescript\n * const bbox = calculateSceneBoundingBox([model1, model2, model3]);\n * const size = bbox.getSize(new THREE.Vector3());\n * console.log(`Scene dimensions: ${size.x} x ${size.y} x ${size.z}`);\n * ```\n */\nexport function calculateSceneBoundingBox(objects: THREE.Object3D[]): THREE.Box3 {\n  const sceneBBox = new THREE.Box3();\n  \n  objects.forEach(obj => {\n    const objBBox = new THREE.Box3().setFromObject(obj);\n    sceneBBox.union(objBBox);\n  });\n  \n  return sceneBBox;\n}\n\n/**\n * Get the maximum dimension of a bounding box\n * \n * @param bbox - The bounding box\n * @returns The largest dimension (x, y, or z)\n * \n * @example\n * ```typescript\n * const bbox = new THREE.Box3().setFromObject(model);\n * const maxDim = getMaxDimension(bbox);\n * const cameraDistance = maxDim * 2; // Position camera based on size\n * ```\n */\nexport function getMaxDimension(bbox: THREE.Box3): number {\n  const size = bbox.getSize(new THREE.Vector3());\n  return Math.max(size.x, size.y, size.z);\n}\n\n/**\n * Calculate optimal camera distance to fit an object in view\n * \n * @param objectSize - The size of the object (max dimension)\n * @param fovDegrees - Camera field of view in degrees\n * @param padding - Padding multiplier (default 1.2 = 20% padding)\n * @returns Optimal camera distance\n * \n * @example\n * ```typescript\n * const maxDim = getMaxDimension(bbox);\n * const distance = calculateCameraDistance(maxDim, 40, 1.5);\n * camera.position.z = distance;\n * ```\n */\nexport function calculateCameraDistance(\n  objectSize: number, \n  fovDegrees: number, \n  padding: number = 1.2\n): number {\n  const fovRadians = fovDegrees * (Math.PI / 180);\n  const distance = (objectSize / 2) / Math.tan(fovRadians / 2);\n  return distance * padding;\n}\n\n/**\n * Center an object at the origin\n * \n * Calculates the offset needed to center an object and returns it.\n * Does not modify the object itself.\n * \n * @param obj - The object to center\n * @returns Offset vector to apply for centering\n * \n * @example\n * ```typescript\n * const offset = calculateCenteringOffset(model);\n * model.position.add(offset);\n * ```\n */\nexport function calculateCenteringOffset(obj: THREE.Object3D): THREE.Vector3 {\n  const bbox = new THREE.Box3().setFromObject(obj);\n  const center = bbox.getCenter(new THREE.Vector3());\n  \n  return new THREE.Vector3(\n    -center.x,\n    -bbox.min.y, // Align bottom to ground\n    -center.z\n  );\n}\n\n/**\n * Calculate centering offset for multiple objects\n * \n * Centers the combined bounding box of all objects.\n * \n * @param objects - Array of objects to center\n * @returns Offset vector to apply to all objects\n * \n * @example\n * ```typescript\n * const offset = calculateSceneCenteringOffset([model1, model2]);\n * model1.position.add(offset);\n * model2.position.add(offset);\n * ```\n */\nexport function calculateSceneCenteringOffset(objects: THREE.Object3D[]): THREE.Vector3 {\n  const bbox = calculateSceneBoundingBox(objects);\n  const center = bbox.getCenter(new THREE.Vector3());\n  \n  return new THREE.Vector3(\n    -center.x,\n    -bbox.min.y,\n    -center.z\n  );\n}\n\n/**\n * Check if an object has a predefined position\n * \n * @param position - Position array from model definition\n * @returns True if position is valid and defined\n */\nexport function hasValidPosition(position: number[] | undefined): boolean {\n  return Array.isArray(position) && position.length === 3;\n}\n\n/**\n * Round position to specified decimal places\n * \n * @param position - Three.js Vector3\n * @param decimals - Number of decimal places (default 3)\n * @returns Rounded position as array [x, y, z]\n * \n * @example\n * ```typescript\n * const rounded = roundPosition(model.position, 2);\n * // [1.23, 4.56, 7.89]\n * ```\n */\nexport function roundPosition(position: THREE.Vector3, decimals: number = 3): [number, number, number] {\n  return [\n    parseFloat(position.x.toFixed(decimals)),\n    parseFloat(position.y.toFixed(decimals)),\n    parseFloat(position.z.toFixed(decimals))\n  ];\n}\n\n/**\n * Format geometry stats as human-readable string\n * \n * @param stats - Geometry statistics\n * @returns Formatted string with key metrics\n * \n * @example\n * ```typescript\n * const stats = calculateObjectStats(model);\n * console.log(formatStats(stats));\n * // \"42.5K triangles, 127.3K vertices, 2.5 x 3.1 x 1.8m, 3 textures\"\n * ```\n */\nexport function formatStats(stats: GeometryStats): string {\n  const formatNumber = (n: number): string => {\n    if (n >= 1000000) return `${(n / 1000000).toFixed(1)}M`;\n    if (n >= 1000) return `${(n / 1000).toFixed(1)}K`;\n    return `${n}`;\n  };\n  \n  const formatDimension = (d: number): string => d.toFixed(1);\n  \n  return `${formatNumber(stats.triangles)} triangles, ` +\n         `${formatNumber(stats.vertices)} vertices, ` +\n         `${formatDimension(stats.bbox.x)} x ${formatDimension(stats.bbox.y)} x ${formatDimension(stats.bbox.z)}m, ` +\n         `${stats.textures.count} texture${stats.textures.count !== 1 ? 's' : ''}`;\n}\n","/**\n * UIControlsBuilder - Builder pattern for creating 3D viewer UI controls\n * \n * This module provides a clean, declarative API for creating button-based UI controls\n * for 3D viewers. It handles:\n * - Button creation with consistent styling\n * - Icon management (Bootstrap Icons)\n * - Event handlers (hover, click)\n * - Container layout and positioning\n * - Responsive hover effects\n * \n * @module UIControlsBuilder\n * @author OCRA Team\n */\n\n/**\n * Configuration for a single button control\n */\nexport interface ButtonConfig {\n  /** Unique identifier for the button */\n  id: string;\n  /** Bootstrap icon class (e.g., 'bi-house', 'bi-camera') */\n  icon: string;\n  /** Custom HTML content (overrides icon if provided) */\n  customHTML?: string;\n  /** Tooltip text on hover */\n  title: string;\n  /** Click event handler */\n  onClick: () => void;\n  /** Initial visibility state */\n  visible?: boolean;\n  /** Additional CSS classes */\n  className?: string;\n}\n\n/**\n * Configuration for the button container\n */\nexport interface ContainerConfig {\n  /** Container position: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' */\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  /** Container layout direction: 'vertical' | 'horizontal' */\n  direction?: 'vertical' | 'horizontal';\n  /** Gap between buttons (Bootstrap gap class, e.g., 'gap-2') */\n  gap?: string;\n  /** Z-index for stacking */\n  zIndex?: string;\n  /** Additional CSS classes */\n  className?: string;\n}\n\n/**\n * Result of building UI controls\n */\nexport interface UIControlsResult {\n  /** The container element holding all buttons */\n  container: HTMLDivElement;\n  /** Map of button elements by ID */\n  buttons: Map<string, HTMLButtonElement>;\n}\n\n/**\n * UIControlsBuilder - Creates and manages UI button controls\n * \n * Example usage:\n * ```typescript\n * const builder = new UIControlsBuilder();\n * const controls = builder\n *   .setContainer({ position: 'top-left', direction: 'vertical' })\n *   .addButton({\n *     id: 'home',\n *     icon: 'bi-house',\n *     title: 'Reset camera view',\n *     onClick: () => this.resetCamera()\n *   })\n *   .addButton({\n *     id: 'screenshot',\n *     icon: 'bi-camera',\n *     title: 'Take screenshot',\n *     onClick: () => this.takeScreenshot()\n *   })\n *   .build();\n * \n * // Attach to mount point\n * mount.appendChild(controls.container);\n * \n * // Access individual buttons\n * const homeButton = controls.buttons.get('home');\n * ```\n */\nexport class UIControlsBuilder {\n  private containerConfig: ContainerConfig = {\n    position: 'top-left',\n    direction: 'vertical',\n    gap: 'gap-2',\n    zIndex: '1000'\n  };\n  \n  private buttons: ButtonConfig[] = [];\n  \n  /**\n   * Configure the button container\n   */\n  setContainer(config: Partial<ContainerConfig>): this {\n    this.containerConfig = { ...this.containerConfig, ...config };\n    return this;\n  }\n  \n  /**\n   * Add a button to the control panel\n   */\n  addButton(config: ButtonConfig): this {\n    this.buttons.push(config);\n    return this;\n  }\n  \n  /**\n   * Add multiple buttons at once\n   */\n  addButtons(configs: ButtonConfig[]): this {\n    this.buttons.push(...configs);\n    return this;\n  }\n  \n  /**\n   * Build the UI controls and return the result\n   */\n  build(): UIControlsResult {\n    const container = this.createContainer();\n    const buttonElements = new Map<string, HTMLButtonElement>();\n    \n    // Create each button\n    for (const config of this.buttons) {\n      const button = this.createButton(config);\n      container.appendChild(button);\n      buttonElements.set(config.id, button);\n    }\n    \n    return {\n      container,\n      buttons: buttonElements\n    };\n  }\n  \n  /**\n   * Create the container element\n   */\n  private createContainer(): HTMLDivElement {\n    const container = document.createElement('div');\n    \n    // Base classes\n    const baseClasses = ['position-absolute', 'd-flex'];\n    \n    // Position classes\n    const positionClasses = this.getPositionClasses(this.containerConfig.position!);\n    \n    // Direction classes\n    const directionClass = this.containerConfig.direction === 'horizontal' \n      ? 'flex-row' \n      : 'flex-column';\n    \n    // Gap\n    const gapClass = this.containerConfig.gap || 'gap-2';\n    \n    // Margin for spacing from edges\n    const marginClass = 'm-2';\n    \n    // Combine all classes\n    const allClasses = [\n      ...baseClasses,\n      ...positionClasses,\n      directionClass,\n      gapClass,\n      marginClass,\n      this.containerConfig.className || ''\n    ].filter(c => c.length > 0);\n    \n    container.className = allClasses.join(' ');\n    container.style.zIndex = this.containerConfig.zIndex || '1000';\n    \n    return container;\n  }\n  \n  /**\n   * Get Bootstrap positioning classes based on position config\n   */\n  private getPositionClasses(position: string): string[] {\n    switch (position) {\n      case 'top-left':\n        return ['top-0', 'start-0'];\n      case 'top-right':\n        return ['top-0', 'end-0'];\n      case 'bottom-left':\n        return ['bottom-0', 'start-0'];\n      case 'bottom-right':\n        return ['bottom-0', 'end-0'];\n      default:\n        return ['top-0', 'start-0'];\n    }\n  }\n  \n  /**\n   * Create a single button element\n   */\n  private createButton(config: ButtonConfig): HTMLButtonElement {\n    const button = document.createElement('button');\n    \n    // Set content - custom HTML or icon\n    if (config.customHTML) {\n      button.innerHTML = config.customHTML;\n    } else {\n      button.innerHTML = `<i class=\"bi ${config.icon}\"></i>`;\n    }\n    \n    // Base button classes - Bootstrap styling\n    // Note: We don't include 'd-flex' here because it uses !important and conflicts with display: none\n    // Instead, we'll set display via inline style\n    const baseClasses = [\n      'btn',\n      'btn-light',\n      'p-2',\n      'shadow-sm',\n      'rounded',\n      'align-items-center',\n      'justify-content-center'\n    ];\n    \n    // Add custom classes if provided\n    const allClasses = [...baseClasses, config.className || ''].filter(c => c.length > 0);\n    button.className = allClasses.join(' ');\n    \n    // Set tooltip\n    button.title = config.title;\n    \n    // Initial visibility - use inline style to override Bootstrap classes\n    if (config.visible === false) {\n      button.style.display = 'none';\n    } else {\n      button.style.display = 'flex';\n    }\n    \n    // Add hover effects for scale animation\n    button.addEventListener('mouseenter', () => {\n      button.style.transform = 'scale(1.05)';\n    });\n    \n    button.addEventListener('mouseleave', () => {\n      button.style.transform = 'scale(1)';\n    });\n    \n    // Add click handler\n    button.addEventListener('click', config.onClick);\n    \n    return button;\n  }\n  \n  /**\n   * Reset the builder to initial state\n   */\n  reset(): this {\n    this.buttons = [];\n    this.containerConfig = {\n      position: 'top-left',\n      direction: 'vertical',\n      gap: 'gap-2',\n      zIndex: '1000'\n    };\n    return this;\n  }\n}\n\n/**\n * Utility function to create a simple button (non-builder pattern)\n * \n * @param config Button configuration\n * @returns The created button element\n */\nexport function createButton(config: ButtonConfig): HTMLButtonElement {\n  const builder = new UIControlsBuilder();\n  builder.addButton(config);\n  const result = builder.build();\n  return result.buttons.get(config.id)!;\n}\n\n/**\n * Utility function to create a button container with buttons\n * \n * @param containerConfig Container configuration\n * @param buttonConfigs Array of button configurations\n * @returns The UI controls result\n */\nexport function createButtonPanel(\n  containerConfig: Partial<ContainerConfig>,\n  buttonConfigs: ButtonConfig[]\n): UIControlsResult {\n  const builder = new UIControlsBuilder();\n  builder.setContainer(containerConfig);\n  builder.addButtons(buttonConfigs);\n  return builder.build();\n}\n","/**\n * CameraManager - Manages camera setup, switching, and positioning\n * \n * This module provides a comprehensive camera management system for Three.js scenes:\n * - Dual camera support (perspective and orthographic)\n * - Smooth camera mode switching with state preservation\n * - Automatic frustum calculation for visual consistency\n * - Camera positioning and reset functionality\n * - Resize handling for both camera types\n * \n * @module CameraManager\n * @author OCRA Team\n */\n\nimport * as THREE from 'three';\n\n/**\n * Configuration for camera initialization\n */\nexport interface CameraConfig {\n  /** Field of view for perspective camera (degrees) */\n  fov?: number;\n  /** Near clipping plane */\n  near?: number;\n  /** Far clipping plane */\n  far?: number;\n  /** Initial frustum size for orthographic camera */\n  frustumSize?: number;\n  /** Initial camera position */\n  initialPosition?: THREE.Vector3;\n  /** Initial controls target */\n  initialTarget?: THREE.Vector3;\n}\n\n/**\n * Camera state for switching between modes\n */\nexport interface CameraState {\n  /** Camera position */\n  position: THREE.Vector3;\n  /** Camera rotation */\n  rotation: THREE.Euler;\n  /** Camera type */\n  type: 'perspective' | 'orthographic';\n  /** Distance to target */\n  distance?: number;\n  /** Target position (for controls) */\n  target?: THREE.Vector3;\n}\n\n/**\n * Camera information\n */\nexport interface CameraInfo {\n  /** Current camera type */\n  type: 'perspective' | 'orthographic';\n  /** Position */\n  position: THREE.Vector3;\n  /** Field of view (perspective only) */\n  fov?: number;\n  /** Frustum dimensions (orthographic only) */\n  frustum?: {\n    left: number;\n    right: number;\n    top: number;\n    bottom: number;\n  };\n}\n\n/**\n * CameraManager - Manages dual camera system (perspective + orthographic)\n * \n * Example usage:\n * ```typescript\n * const cameraManager = new CameraManager(aspect, {\n *   fov: 45,\n *   initialPosition: new THREE.Vector3(0, 1, 3)\n * });\n * \n * const camera = cameraManager.getActiveCamera();\n * \n * // Switch camera mode\n * cameraManager.toggleCameraMode(controls);\n * \n * // Reset to initial position\n * cameraManager.resetCamera(controls);\n * \n * // Handle window resize\n * cameraManager.handleResize(newWidth, newHeight);\n * ```\n */\nexport class CameraManager {\n  private perspectiveCamera: THREE.PerspectiveCamera;\n  private orthographicCamera: THREE.OrthographicCamera;\n  private activeCamera: THREE.PerspectiveCamera | THREE.OrthographicCamera;\n  private isOrthographic: boolean = false;\n  \n  private initialPosition: THREE.Vector3;\n  private initialTarget: THREE.Vector3;\n  private frustumSize: number;\n  private currentAspect: number;\n  \n  /**\n   * Create a new CameraManager\n   * \n   * @param aspect Initial aspect ratio (width / height)\n   * @param config Camera configuration\n   */\n  constructor(aspect: number, config: CameraConfig = {}) {\n    const {\n      fov = 40,\n      near = 0.1,\n      far = 1000,\n      frustumSize = 2,\n      initialPosition = new THREE.Vector3(0, 0, 2),\n      initialTarget = new THREE.Vector3(0, 0, 0)\n    } = config;\n    \n    this.currentAspect = aspect;\n    this.frustumSize = frustumSize;\n    this.initialPosition = initialPosition.clone();\n    this.initialTarget = initialTarget.clone();\n    \n    // Create perspective camera\n    this.perspectiveCamera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    this.perspectiveCamera.position.copy(initialPosition);\n    \n    // Create orthographic camera\n    this.orthographicCamera = new THREE.OrthographicCamera(\n      frustumSize * aspect / -2,\n      frustumSize * aspect / 2,\n      frustumSize / 2,\n      frustumSize / -2,\n      near,\n      far\n    );\n    this.orthographicCamera.position.copy(initialPosition);\n    \n    // Start with perspective camera\n    this.activeCamera = this.perspectiveCamera;\n  }\n  \n  /**\n   * Get the currently active camera\n   */\n  getActiveCamera(): THREE.PerspectiveCamera | THREE.OrthographicCamera {\n    return this.activeCamera;\n  }\n  \n  /**\n   * Get the perspective camera\n   */\n  getPerspectiveCamera(): THREE.PerspectiveCamera {\n    return this.perspectiveCamera;\n  }\n  \n  /**\n   * Get the orthographic camera\n   */\n  getOrthographicCamera(): THREE.OrthographicCamera {\n    return this.orthographicCamera;\n  }\n  \n  /**\n   * Check if currently using orthographic camera\n   */\n  isOrthographicMode(): boolean {\n    return this.isOrthographic;\n  }\n  \n  /**\n   * Get current camera type\n   */\n  getCameraType(): 'perspective' | 'orthographic' {\n    return this.isOrthographic ? 'orthographic' : 'perspective';\n  }\n  \n  /**\n   * Get camera information\n   */\n  getCameraInfo(): CameraInfo {\n    const info: CameraInfo = {\n      type: this.getCameraType(),\n      position: this.activeCamera.position.clone()\n    };\n    \n    if (this.isOrthographic) {\n      info.frustum = {\n        left: this.orthographicCamera.left,\n        right: this.orthographicCamera.right,\n        top: this.orthographicCamera.top,\n        bottom: this.orthographicCamera.bottom\n      };\n    } else {\n      info.fov = this.perspectiveCamera.fov;\n    }\n    \n    return info;\n  }\n  \n  /**\n   * Toggle between perspective and orthographic camera\n   * \n   * @param controls Optional OrbitControls to update\n   * @returns The new active camera\n   */\n  toggleCameraMode(controls?: any): THREE.PerspectiveCamera | THREE.OrthographicCamera {\n    // Store current camera state\n    const currentPos = this.activeCamera.position.clone();\n    const currentTarget = controls?.target.clone() || this.initialTarget.clone();\n    const distance = currentPos.distanceTo(currentTarget);\n    \n    // Switch camera\n    this.isOrthographic = !this.isOrthographic;\n    \n    if (this.isOrthographic) {\n      // Switch to orthographic\n      // Calculate frustum size based on perspective camera's FOV and distance\n      // This ensures visual consistency when switching\n      const fov = this.perspectiveCamera.fov * (Math.PI / 180); // Convert to radians\n      const frustumHeight = 2 * Math.tan(fov / 2) * distance;\n      const frustumWidth = frustumHeight * this.currentAspect;\n      \n      this.orthographicCamera.left = -frustumWidth / 2;\n      this.orthographicCamera.right = frustumWidth / 2;\n      this.orthographicCamera.top = frustumHeight / 2;\n      this.orthographicCamera.bottom = -frustumHeight / 2;\n      this.orthographicCamera.position.copy(currentPos);\n      this.orthographicCamera.updateProjectionMatrix();\n      \n      this.activeCamera = this.orthographicCamera;\n    } else {\n      // Switch to perspective\n      this.perspectiveCamera.position.copy(currentPos);\n      this.activeCamera = this.perspectiveCamera;\n    }\n    \n    // Update controls to use new camera\n    if (controls) {\n      controls.object = this.activeCamera;\n      controls.target.copy(currentTarget);\n      controls.update();\n    }\n    \n    return this.activeCamera;\n  }\n  \n  /**\n   * Reset camera to initial position and target\n   * \n   * @param controls Optional OrbitControls to update\n   */\n  resetCamera(controls?: any): void {\n    this.activeCamera.position.copy(this.initialPosition);\n    \n    if (controls) {\n      controls.target.copy(this.initialTarget);\n      controls.update();\n    }\n  }\n  \n  /**\n   * Set initial camera position (for reset)\n   * \n   * @param position New initial position\n   */\n  setInitialPosition(position: THREE.Vector3): void {\n    this.initialPosition.copy(position);\n  }\n  \n  /**\n   * Set initial target position (for reset)\n   * \n   * @param target New initial target\n   */\n  setInitialTarget(target: THREE.Vector3): void {\n    this.initialTarget.copy(target);\n  }\n  \n  /**\n   * Update both cameras for the current position/target\n   * Useful when programmatically moving the camera\n   * \n   * @param position New camera position\n   * @param target New target position\n   * @param controls Optional controls to update\n   */\n  updateCameraPosition(position: THREE.Vector3, target?: THREE.Vector3, controls?: any): void {\n    this.activeCamera.position.copy(position);\n    \n    // Also update the inactive camera so switching is seamless\n    if (this.isOrthographic) {\n      this.perspectiveCamera.position.copy(position);\n    } else {\n      this.orthographicCamera.position.copy(position);\n    }\n    \n    if (controls && target) {\n      controls.target.copy(target);\n      controls.update();\n    }\n  }\n  \n  /**\n   * Handle window resize - updates both cameras\n   * \n   * @param width New width in pixels\n   * @param height New height in pixels\n   */\n  handleResize(width: number, height: number): void {\n    const aspect = width / height;\n    this.currentAspect = aspect;\n    \n    // Update perspective camera\n    this.perspectiveCamera.aspect = aspect;\n    this.perspectiveCamera.updateProjectionMatrix();\n    \n    // Update orthographic camera\n    this.orthographicCamera.left = this.frustumSize * aspect / -2;\n    this.orthographicCamera.right = this.frustumSize * aspect / 2;\n    this.orthographicCamera.top = this.frustumSize / 2;\n    this.orthographicCamera.bottom = this.frustumSize / -2;\n    this.orthographicCamera.updateProjectionMatrix();\n    \n    // Update active camera reference (important for type narrowing)\n    if (this.activeCamera instanceof THREE.PerspectiveCamera) {\n      this.activeCamera.aspect = aspect;\n    } else if (this.activeCamera instanceof THREE.OrthographicCamera) {\n      this.activeCamera.left = this.frustumSize * aspect / -2;\n      this.activeCamera.right = this.frustumSize * aspect / 2;\n      this.activeCamera.top = this.frustumSize / 2;\n      this.activeCamera.bottom = this.frustumSize / -2;\n    }\n    this.activeCamera.updateProjectionMatrix();\n  }\n  \n  /**\n   * Save current camera state\n   * \n   * @param controls Optional controls to save target from\n   * @returns CameraState object\n   */\n  saveCameraState(controls?: any): CameraState {\n    return {\n      position: this.activeCamera.position.clone(),\n      rotation: this.activeCamera.rotation.clone(),\n      type: this.getCameraType(),\n      distance: controls ? this.activeCamera.position.distanceTo(controls.target) : undefined,\n      target: controls?.target.clone()\n    };\n  }\n  \n  /**\n   * Restore camera state\n   * \n   * @param state CameraState to restore\n   * @param controls Optional controls to update\n   */\n  restoreCameraState(state: CameraState, controls?: any): void {\n    // Switch to correct camera type if needed\n    if (state.type !== this.getCameraType()) {\n      this.toggleCameraMode(controls);\n    }\n    \n    // Restore position and rotation\n    this.activeCamera.position.copy(state.position);\n    this.activeCamera.rotation.copy(state.rotation);\n    \n    // Restore target\n    if (controls && state.target) {\n      controls.target.copy(state.target);\n      controls.update();\n    }\n  }\n  \n  /**\n   * Get the initial position\n   */\n  getInitialPosition(): THREE.Vector3 {\n    return this.initialPosition.clone();\n  }\n  \n  /**\n   * Get the initial target\n   */\n  getInitialTarget(): THREE.Vector3 {\n    return this.initialTarget.clone();\n  }\n  \n  /**\n   * Calculate optimal camera distance for a given bounding box\n   * \n   * @param boundingBox The bounding box to frame\n   * @param padding Optional padding factor (default 1.2)\n   * @returns Optimal camera distance\n   */\n  calculateOptimalDistance(boundingBox: THREE.Box3, padding: number = 1.2): number {\n    const size = new THREE.Vector3();\n    boundingBox.getSize(size);\n    const maxDim = Math.max(size.x, size.y, size.z);\n    \n    if (this.isOrthographic) {\n      return maxDim * padding;\n    } else {\n      const fov = this.perspectiveCamera.fov * (Math.PI / 180);\n      return (maxDim / 2) / Math.tan(fov / 2) * padding;\n    }\n  }\n  \n  /**\n   * Frame a bounding box - positions camera to view entire box\n   * \n   * @param boundingBox The bounding box to frame\n   * @param controls Optional controls to update\n   * @param padding Optional padding factor (default 1.2)\n   */\n  frameBoundingBox(boundingBox: THREE.Box3, controls?: any, padding: number = 1.2): void {\n    const center = new THREE.Vector3();\n    boundingBox.getCenter(center);\n    \n    const distance = this.calculateOptimalDistance(boundingBox, padding);\n    \n    // Position camera along current direction\n    const direction = new THREE.Vector3();\n    this.activeCamera.getWorldDirection(direction);\n    direction.multiplyScalar(-1); // Point away from target\n    \n    const newPosition = center.clone().add(direction.multiplyScalar(distance));\n    \n    this.updateCameraPosition(newPosition, center, controls);\n  }\n  \n  /**\n   * Dispose of cameras (cleanup)\n   */\n  dispose(): void {\n    // Cameras don't have explicit dispose methods, but we can clear references\n    // This is mainly for completeness\n  }\n}\n\n/**\n * Utility function to create a camera manager with default settings\n * \n * @param aspect Aspect ratio\n * @returns CameraManager instance\n */\nexport function createCameraManager(aspect: number): CameraManager {\n  return new CameraManager(aspect);\n}\n\n/**\n * Utility function to calculate frustum size from FOV and distance\n * \n * @param fov Field of view in degrees\n * @param distance Distance to target\n * @returns Frustum height\n */\nexport function calculateFrustumSize(fov: number, distance: number): number {\n  const fovRadians = fov * (Math.PI / 180);\n  return 2 * Math.tan(fovRadians / 2) * distance;\n}\n","import * as THREE from 'three';\n\n/**\n * Configuration for lighting setup\n */\nexport interface LightingConfig {\n  /** Initial intensity for ambient light (default: 0.1) */\n  ambientIntensity?: number;\n  /** Initial intensity for directional head light (default: 0.9) */\n  headLightIntensity?: number;\n  /** Color of lights (default: 0xffffff) */\n  lightColor?: number;\n  /** Initial head light offset in radians [horizontal, vertical] (default: [0, 0]) */\n  initialOffset?: THREE.Vector2;\n}\n\n/**\n * Current state of lighting system\n */\nexport interface LightingState {\n  /** Whether head light is enabled */\n  headLightEnabled: boolean;\n  /** Whether environment lighting is enabled */\n  envLightingEnabled: boolean;\n  /** Current head light intensity */\n  headLightIntensity: number;\n  /** Current angular offset [horizontal, vertical] in radians */\n  headLightOffset: THREE.Vector2;\n}\n\n/**\n * LightingManager handles all lighting for the 3D scene.\n * \n * Features:\n * - Ambient lighting for base illumination\n * - Directional head light that follows camera\n * - Environment map lighting support\n * - Configurable head light offset (angular position relative to camera)\n * - Toggle controls for head light and environment lighting\n * \n * The head light uses a sophisticated offset system:\n * - headLightOffset.x: horizontal angle (theta) in radians (positive ‚Üí rotate right)\n * - headLightOffset.y: vertical angle (phi) in radians (positive ‚Üí rotate up)\n * - Offset is relative to camera direction, maintaining consistent distance\n * \n * @example\n * ```typescript\n * const manager = new LightingManager(scene, {\n *   ambientIntensity: 0.1,\n *   headLightIntensity: 0.9\n * });\n * \n * // In animation loop\n * manager.updateHeadLight(camera, controls.target);\n * \n * // Toggle lighting\n * manager.toggleHeadLight();\n * manager.toggleEnvironmentLighting();\n * ```\n */\nexport class LightingManager {\n  private scene: THREE.Scene;\n  private ambientLight: THREE.AmbientLight;\n  private headLight: THREE.DirectionalLight;\n  private headLightOffset: THREE.Vector2;\n  private headLightEnabled: boolean = true;\n  private envLightingEnabled: boolean = true;\n  private envMap: THREE.Texture | null = null;\n  private config: Required<LightingConfig>;\n\n  /**\n   * Create a new lighting manager\n   * @param scene The Three.js scene to add lights to\n   * @param config Configuration options for lighting\n   */\n  constructor(scene: THREE.Scene, config: LightingConfig = {}) {\n    this.scene = scene;\n    \n    // Set defaults\n    this.config = {\n      ambientIntensity: config.ambientIntensity ?? 0.1,\n      headLightIntensity: config.headLightIntensity ?? 0.9,\n      lightColor: config.lightColor ?? 0xffffff,\n      initialOffset: config.initialOffset ?? new THREE.Vector2(0, 0)\n    };\n\n    // Create ambient light\n    this.ambientLight = new THREE.AmbientLight(\n      this.config.lightColor,\n      this.config.ambientIntensity\n    );\n    this.scene.add(this.ambientLight);\n\n    // Create directional head light\n    this.headLight = new THREE.DirectionalLight(\n      this.config.lightColor,\n      this.config.headLightIntensity\n    );\n    this.headLight.position.set(0, 0, 1); // Initial position\n    this.scene.add(this.headLight);\n\n    // Initialize offset\n    this.headLightOffset = this.config.initialOffset.clone();\n  }\n\n  /**\n   * Update head light position based on camera position and controls target.\n   * This should be called in the animation loop for smooth tracking.\n   * \n   * The head light maintains a fixed angular offset from the camera direction,\n   * following the camera while respecting the configured offset angles.\n   * \n   * @param camera The active camera\n   * @param target The point the camera is looking at (typically controls.target)\n   */\n  updateHeadLight(camera: THREE.Camera, target: THREE.Vector3 = new THREE.Vector3(0, 0, 0)): void {\n    if (!this.headLight) return;\n\n    // Apply angular offset to position head light relative to camera\n    this.applyHeadLightOffset(camera, target);\n\n    // Point the light towards the target\n    this.headLight.lookAt(target);\n  }\n\n  /**\n   * Apply the angular headLightOffset to compute headLight position relative to camera.\n   * \n   * Algorithm:\n   * 1. Get camera direction in spherical coordinates (theta, phi)\n   * 2. Add offset angles\n   * 3. Convert back to Cartesian coordinates\n   * 4. Maintain same distance from target as camera\n   * \n   * @param camera The active camera\n   * @param target The point to position relative to\n   */\n  private applyHeadLightOffset(camera: THREE.Camera, target: THREE.Vector3): void {\n    if (!this.headLight) return;\n\n    // Base camera direction (from target to camera)\n    const camDir = new THREE.Vector3()\n      .subVectors(camera.position, target)\n      .normalize();\n\n    // Convert camDir to spherical coordinates\n    // thetaCam: azimuth around Y axis, phiCam: polar angle from Y axis\n    const thetaCam = Math.atan2(camDir.x, camDir.z);\n    const phiCam = Math.acos(Math.max(-1, Math.min(1, camDir.y))); // Clamp to [0, PI]\n\n    // Apply offsets\n    const theta = thetaCam + this.headLightOffset.x;\n    const phi = Math.max(0.01, Math.min(Math.PI - 0.01, phiCam + this.headLightOffset.y));\n\n    // Distance: keep same distance from target as camera\n    const camDistance = camera.position.distanceTo(target);\n\n    // Convert back to Cartesian\n    const r = camDistance;\n    const x = target.x + r * Math.sin(phi) * Math.sin(theta);\n    const y = target.y + r * Math.cos(phi);\n    const z = target.z + r * Math.sin(phi) * Math.cos(theta);\n\n    this.headLight.position.set(x, y, z);\n  }\n\n  /**\n   * Set the head light angular offset.\n   * \n   * @param offset Angular offset [horizontal, vertical] in radians\n   *   - x (horizontal): positive = rotate right\n   *   - y (vertical): positive = rotate up\n   */\n  setHeadLightOffset(offset: THREE.Vector2): void {\n    this.headLightOffset.copy(offset);\n  }\n\n  /**\n   * Set the head light offset from degrees (convenience method).\n   * Useful when loading from configuration files that store degrees.\n   * \n   * @param horizontalDegrees Horizontal angle in degrees\n   * @param verticalDegrees Vertical angle in degrees\n   */\n  setHeadLightOffsetFromDegrees(horizontalDegrees: number, verticalDegrees: number): void {\n    const degToRad = Math.PI / 180;\n    this.headLightOffset.set(\n      horizontalDegrees * degToRad,\n      verticalDegrees * degToRad\n    );\n  }\n\n  /**\n   * Get the current head light offset in radians\n   */\n  getHeadLightOffset(): THREE.Vector2 {\n    return this.headLightOffset.clone();\n  }\n\n  /**\n   * Toggle head light on/off\n   * @returns New state (true = enabled, false = disabled)\n   */\n  toggleHeadLight(): boolean {\n    this.headLightEnabled = !this.headLightEnabled;\n    this.headLight.intensity = this.headLightEnabled ? this.config.headLightIntensity : 0;\n    return this.headLightEnabled;\n  }\n\n  /**\n   * Set head light enabled state\n   * @param enabled Whether to enable the head light\n   */\n  setHeadLightEnabled(enabled: boolean): void {\n    this.headLightEnabled = enabled;\n    this.headLight.intensity = enabled ? this.config.headLightIntensity : 0;\n  }\n\n  /**\n   * Check if head light is enabled\n   */\n  isHeadLightEnabled(): boolean {\n    return this.headLightEnabled;\n  }\n\n  /**\n   * Set the head light intensity\n   * @param intensity Light intensity (0 to 1+)\n   */\n  setHeadLightIntensity(intensity: number): void {\n    this.config.headLightIntensity = intensity;\n    if (this.headLightEnabled) {\n      this.headLight.intensity = intensity;\n    }\n  }\n\n  /**\n   * Set the environment map for IBL (Image-Based Lighting)\n   * @param envMap The environment texture or null to clear\n   */\n  setEnvironmentMap(envMap: THREE.Texture | null): void {\n    this.envMap = envMap;\n    if (this.envLightingEnabled) {\n      this.scene.environment = envMap;\n    }\n  }\n\n  /**\n   * Toggle environment lighting on/off\n   * @returns New state (true = enabled, false = disabled)\n   */\n  toggleEnvironmentLighting(): boolean {\n    this.envLightingEnabled = !this.envLightingEnabled;\n    this.scene.environment = this.envLightingEnabled ? this.envMap : null;\n    return this.envLightingEnabled;\n  }\n\n  /**\n   * Set environment lighting enabled state\n   * @param enabled Whether to enable environment lighting\n   */\n  setEnvironmentLightingEnabled(enabled: boolean): void {\n    this.envLightingEnabled = enabled;\n    this.scene.environment = enabled ? this.envMap : null;\n  }\n\n  /**\n   * Check if environment lighting is enabled\n   */\n  isEnvironmentLightingEnabled(): boolean {\n    return this.envLightingEnabled;\n  }\n\n  /**\n   * Get the current lighting state\n   */\n  getState(): LightingState {\n    return {\n      headLightEnabled: this.headLightEnabled,\n      envLightingEnabled: this.envLightingEnabled,\n      headLightIntensity: this.headLight.intensity,\n      headLightOffset: this.headLightOffset.clone()\n    };\n  }\n\n  /**\n   * Get the ambient light object\n   */\n  getAmbientLight(): THREE.AmbientLight {\n    return this.ambientLight;\n  }\n\n  /**\n   * Get the directional head light object\n   */\n  getHeadLight(): THREE.DirectionalLight {\n    return this.headLight;\n  }\n\n  /**\n   * Set ambient light intensity\n   * @param intensity Light intensity (0 to 1+)\n   */\n  setAmbientIntensity(intensity: number): void {\n    this.config.ambientIntensity = intensity;\n    this.ambientLight.intensity = intensity;\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    if (this.ambientLight) {\n      this.scene.remove(this.ambientLight);\n      this.ambientLight.dispose();\n    }\n    if (this.headLight) {\n      this.scene.remove(this.headLight);\n      this.headLight.dispose();\n    }\n  }\n}\n","import * as THREE from 'three';\n\n/**\n * Configuration for model loading\n */\nexport interface LoaderConfig {\n  /** Path to Draco decoder (default: Google CDN) */\n  dracoDecoderPath?: string;\n  /** Draco decoder type (default: 'js') */\n  dracoDecoderType?: 'js' | 'wasm';\n  /** Whether to automatically compute vertex normals for PLY (default: true) */\n  autoComputeNormals?: boolean;\n  /** Default material properties for PLY files */\n  defaultMaterial?: {\n    color?: number;\n    flatShading?: boolean;\n    metalness?: number;\n    roughness?: number;\n  };\n}\n\n/**\n * Material properties that can be applied to loaded models\n */\nexport interface MaterialProperties {\n  color?: number;\n  flatShading?: boolean;\n  metalness?: number;\n  roughness?: number;\n}\n\n/**\n * Progress callback for loading operations\n */\nexport type ProgressCallback = (loaded: number, total: number, percentage: number) => void;\n\n/**\n * Result of a successful load operation\n */\nexport interface LoadResult {\n  /** The loaded Three.js object */\n  object: THREE.Object3D;\n  /** The original format that was loaded */\n  format: 'ply' | 'gltf' | 'glb' | 'nxs' | 'nxz';\n  /** Size of the loaded data in bytes */\n  byteSize: number;\n}\n\n/**\n * ModelLoader handles loading of 3D model files in various formats.\n * \n * Supported formats:\n * - PLY (Polygon File Format)\n * - GLTF (GL Transmission Format)\n * - GLB (GLTF Binary)\n * \n * Features:\n * - Automatic format detection from file extension\n * - Draco compression support for GLTF/GLB\n * - Material property overrides\n * - Progress tracking\n * - Error handling with detailed messages\n * - Lazy loading of format-specific loaders\n * \n * @example\n * ```typescript\n * const loader = new ModelLoader({\n *   dracoDecoderPath: 'https://cdn.com/draco/',\n *   defaultMaterial: { color: 0xcccccc }\n * });\n * \n * // Load from URL\n * const result = await loader.loadFromUrl('/models/scene.glb');\n * scene.add(result.object);\n * \n * // Load from buffer with material override\n * const buffer = await fetch('/models/mesh.ply').then(r => r.arrayBuffer());\n * const result = await loader.loadFromBuffer(buffer, 'ply', {\n *   color: 0xff0000,\n *   metalness: 0.8\n * });\n * ```\n */\nexport class ModelLoader {\n  private config: Required<LoaderConfig>;\n  private plyLoader: any = null;\n  private gltfLoader: any = null;\n  private dracoLoader: any = null;\n\n  /**\n   * Create a new model loader\n   * @param config Configuration options\n   */\n  constructor(config: LoaderConfig = {}) {\n    this.config = {\n      dracoDecoderPath: config.dracoDecoderPath ?? 'https://www.gstatic.com/draco/versioned/decoders/1.5.6/',\n      dracoDecoderType: config.dracoDecoderType ?? 'js',\n      autoComputeNormals: config.autoComputeNormals ?? true,\n      defaultMaterial: {\n        color: config.defaultMaterial?.color ?? 0xdddddd,\n        flatShading: config.defaultMaterial?.flatShading ?? true,\n        metalness: config.defaultMaterial?.metalness,\n        roughness: config.defaultMaterial?.roughness\n      }\n    };\n  }\n\n  /**\n   * Load a model from a URL.\n   * Automatically detects format from file extension.\n   * \n   * @param url URL to load from\n   * @param materialOverrides Optional material property overrides\n   * @param onProgress Optional progress callback\n   * @returns Promise resolving to load result\n   */\n  async loadFromUrl(\n    url: string,\n    materialOverrides?: MaterialProperties,\n    onProgress?: ProgressCallback\n  ): Promise<LoadResult> {\n    // Detect format from URL\n    const format = this.detectFormat(url);\n    \n    // For NXS/NXZ files, use direct URL loading (streaming)\n    if (format === 'nxs' || format === 'nxz') {\n      const object = await this.parseNexus(url, materialOverrides);\n      return {\n        object,\n        format,\n        byteSize: 0 // NXS is streamed, size unknown\n      };\n    }\n    \n    // For other formats, fetch the file\n    const response = await fetch(url, { credentials: 'include' });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to load model from ${url}: HTTP ${response.status}`);\n    }\n\n    // Get content length for progress tracking\n    const contentLength = parseInt(response.headers.get('content-length') || '0', 10);\n    \n    // Read the response with progress tracking\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n\n    const chunks: Uint8Array[] = [];\n    let receivedLength = 0;\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      chunks.push(value);\n      receivedLength += value.length;\n\n      if (onProgress && contentLength > 0) {\n        const percentage = (receivedLength / contentLength) * 100;\n        onProgress(receivedLength, contentLength, percentage);\n      }\n    }\n\n    // Concatenate chunks into single buffer\n    const buffer = new Uint8Array(receivedLength);\n    let position = 0;\n    for (const chunk of chunks) {\n      buffer.set(chunk, position);\n      position += chunk.length;\n    }\n    \n    // Load from buffer\n    return this.loadFromBuffer(buffer.buffer, format, materialOverrides, url);\n  }\n\n  /**\n   * Load a model from an ArrayBuffer.\n   * \n   * @param buffer ArrayBuffer containing the model data\n   * @param format File format ('ply', 'gltf', 'glb', 'nxs', or 'nxz')\n   * @param materialOverrides Optional material property overrides\n   * @param url Optional URL for streaming formats like NXS\n   * @returns Promise resolving to load result\n   */\n  async loadFromBuffer(\n    buffer: ArrayBuffer,\n    format: 'ply' | 'gltf' | 'glb' | 'nxs' | 'nxz',\n    materialOverrides?: MaterialProperties,\n    url?: string\n  ): Promise<LoadResult> {\n    let object: THREE.Object3D;\n\n    switch (format) {\n      case 'ply':\n        object = await this.parsePLY(buffer, materialOverrides);\n        break;\n      case 'gltf':\n      case 'glb':\n        object = await this.parseGLTF(buffer, materialOverrides);\n        break;\n      case 'nxs':\n      case 'nxz':\n        // For NXS/NXZ, we need the URL for streaming, not the buffer\n        if (!url) {\n          throw new Error('NXS/NXZ format requires URL for streaming');\n        }\n        object = await this.parseNexus(url, materialOverrides);\n        break;\n      default:\n        throw new Error(`Unsupported format: ${format}`);\n    }\n\n    return {\n      object,\n      format,\n      byteSize: buffer.byteLength\n    };\n  }\n\n  /**\n   * Detect file format from filename or URL\n   * @param filename Filename or URL\n   * @returns Detected format\n   */\n  detectFormat(filename: string): 'ply' | 'gltf' | 'glb' | 'nxs' | 'nxz' {\n    const lower = filename.toLowerCase();\n    \n    if (lower.endsWith('.ply')) {\n      return 'ply';\n    } else if (lower.endsWith('.glb')) {\n      return 'glb';\n    } else if (lower.endsWith('.gltf')) {\n      return 'gltf';\n    } else if (lower.endsWith('.nxs')) {\n      return 'nxs';\n    } else if (lower.endsWith('.nxz')) {\n      return 'nxz';\n    }\n    \n    throw new Error(`Cannot detect format from filename: ${filename}`);\n  }\n\n  /**\n   * Parse PLY format buffer\n   * @param buffer ArrayBuffer containing PLY data\n   * @param materialOverrides Optional material overrides\n   * @returns Promise resolving to Three.js Mesh\n   */\n  private async parsePLY(\n    buffer: ArrayBuffer,\n    materialOverrides?: MaterialProperties\n  ): Promise<THREE.Mesh> {\n    // Lazy load PLYLoader\n    if (!this.plyLoader) {\n      const { PLYLoader } = await import('three/addons/loaders/PLYLoader.js');\n      this.plyLoader = new PLYLoader();\n    }\n\n    // Parse geometry\n    const geometry = this.plyLoader.parse(buffer);\n    \n    // Compute normals if enabled\n    if (this.config.autoComputeNormals) {\n      geometry.computeVertexNormals();\n    }\n\n    // Create material with defaults and overrides\n    const materialProps = this.mergeMaterialProperties(\n      this.config.defaultMaterial,\n      materialOverrides\n    );\n\n    const material = new THREE.MeshStandardMaterial({\n      color: materialProps.color,\n      flatShading: materialProps.flatShading,\n      metalness: materialProps.metalness,\n      roughness: materialProps.roughness\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    return mesh;\n  }\n\n  /**\n   * Parse GLTF/GLB format buffer\n   * @param buffer ArrayBuffer containing GLTF/GLB data\n   * @param materialOverrides Optional material overrides\n   * @returns Promise resolving to Three.js Group\n   */\n  private async parseGLTF(\n    buffer: ArrayBuffer,\n    materialOverrides?: MaterialProperties\n  ): Promise<THREE.Group> {\n    // Lazy load GLTF and Draco loaders\n    if (!this.gltfLoader) {\n      const [{ GLTFLoader }, { DRACOLoader }] = await Promise.all([\n        import('three/addons/loaders/GLTFLoader.js'),\n        import('three/addons/loaders/DRACOLoader.js')\n      ]);\n\n      this.gltfLoader = new GLTFLoader();\n\n      // Set up Draco decoder\n      this.dracoLoader = new DRACOLoader();\n      this.dracoLoader.setDecoderPath(this.config.dracoDecoderPath);\n      this.dracoLoader.setDecoderConfig({ type: this.config.dracoDecoderType });\n      this.gltfLoader.setDRACOLoader(this.dracoLoader);\n    }\n\n    // Parse GLTF\n    return new Promise<THREE.Group>((resolve, reject) => {\n      this.gltfLoader.parse(\n        buffer,\n        '', // Resource path (not needed for buffer parsing)\n        (gltf: any) => {\n          const group = new THREE.Group();\n          \n          // Clone all meshes from the scene\n          gltf.scene.traverse((child: any) => {\n            if ((child as THREE.Mesh).isMesh) {\n              const clonedChild = child.clone();\n\n              // Apply material overrides if specified\n              if (materialOverrides && (clonedChild as THREE.Mesh).material) {\n                this.applyMaterialOverrides(\n                  (clonedChild as THREE.Mesh).material as THREE.Material,\n                  materialOverrides\n                );\n              }\n\n              group.add(clonedChild);\n            }\n          });\n          \n          resolve(group);\n        },\n        (error: any) => {\n          reject(new Error(`Failed to parse GLTF: ${error.message || error}`));\n        }\n      );\n    });\n  }\n\n  /**\n   * Parse Nexus (NXS/NXZ) format from URL\n   * Nexus is a multiresolution format that streams data incrementally\n   * @param url URL to the .nxs or .nxz file\n   * @param materialOverrides Optional material overrides (not typically used with Nexus)\n   * @returns Promise resolving to NexusObject\n   */\n  private async parseNexus(\n    url: string,\n    materialOverrides?: MaterialProperties\n  ): Promise<THREE.Object3D> {\n    // Lazy load nexus3d library\n    const { NexusObject } = await import('nexus3d');\n    \n    // Create a NexusObject instance\n    // NexusObject extends THREE.Mesh and handles streaming automatically\n    const nexusObject = new NexusObject(\n      url,\n      () => console.log('‚úÖ Nexus model loaded:', url),\n      () => console.log('üîÑ Nexus model updated (new data streamed)'),\n      (error: Error) => console.error('‚ùå Nexus error:', error)\n    );\n    \n    // NexusObject is a THREE.Mesh that manages its own material and geometry\n    // The material is created internally by Nexus and updated during streaming\n    \n    console.log('üîÑ Nexus model created, streaming will begin automatically:', url);\n    \n    return nexusObject;\n  }\n\n  /**\n   * Apply material property overrides to an existing material\n   * @param material Three.js material to modify\n   * @param overrides Properties to override\n   */\n  private applyMaterialOverrides(\n    material: THREE.Material,\n    overrides: MaterialProperties\n  ): void {\n    const mat = material as any;\n\n    if (mat.color && overrides.color !== undefined) {\n      mat.color = new THREE.Color(overrides.color);\n    }\n\n    if (mat.metalness !== undefined && overrides.metalness !== undefined) {\n      mat.metalness = overrides.metalness;\n    }\n\n    if (mat.roughness !== undefined && overrides.roughness !== undefined) {\n      mat.roughness = overrides.roughness;\n    }\n\n    if (overrides.flatShading !== undefined) {\n      mat.flatShading = overrides.flatShading;\n      mat.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Merge material properties, with overrides taking precedence\n   * @param defaults Default properties\n   * @param overrides Override properties\n   * @returns Merged properties\n   */\n  private mergeMaterialProperties(\n    defaults: MaterialProperties,\n    overrides?: MaterialProperties\n  ): Required<MaterialProperties> {\n    return {\n      color: overrides?.color ?? defaults.color ?? 0xdddddd,\n      flatShading: overrides?.flatShading ?? defaults.flatShading ?? true,\n      metalness: overrides?.metalness ?? defaults.metalness ?? 0.5,\n      roughness: overrides?.roughness ?? defaults.roughness ?? 0.5\n    };\n  }\n\n  /**\n   * Get the current configuration\n   */\n  getConfig(): Readonly<Required<LoaderConfig>> {\n    return { ...this.config };\n  }\n\n  /**\n   * Update the Draco decoder path\n   * @param path New path to Draco decoder\n   */\n  setDracoDecoderPath(path: string): void {\n    this.config.dracoDecoderPath = path;\n    if (this.dracoLoader) {\n      this.dracoLoader.setDecoderPath(path);\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  dispose(): void {\n    if (this.dracoLoader) {\n      this.dracoLoader.dispose();\n      this.dracoLoader = null;\n    }\n    this.plyLoader = null;\n    this.gltfLoader = null;\n  }\n}\n\n/**\n * Convenience function to create a model loader with default configuration\n */\nexport function createModelLoader(config?: LoaderConfig): ModelLoader {\n  return new ModelLoader(config);\n}\n","import * as THREE from 'three';\nimport { AnnotationManager } from './managers/AnnotationManager';\nimport type { FileUrlResolver } from './types/FileUrlResolver';\nimport { StaticBaseUrlResolver } from './types/FileUrlResolver';\nimport { calculateObjectStats, type GeometryStats } from './utils/GeometryUtils';\nimport { UIControlsBuilder, type ButtonConfig } from './ui/UIControlsBuilder';\nimport { CameraManager, type CameraConfig } from './managers/CameraManager';\nimport { LightingManager } from './managers/LightingManager';\nimport { ModelLoader } from './managers/ModelLoader';\n// Note: heavy three/examples and viewport gizmo are dynamically imported where needed\nimport type { \n  SceneDescription, \n  ModelDefinition, \n  PresenterState,\n  Annotation\n} from './types/SceneTypes';\n\nexport type { SceneDescription, ModelDefinition, PresenterState };\nexport { AnnotationManager };\n\n/**\n * Progress information for model loading\n */\nexport interface LoadingProgress {\n  modelId: string;\n  fileName: string;\n  loaded: number;\n  total: number;\n  percentage: number;\n  status: 'loading' | 'parsing' | 'complete' | 'error';\n}\n\n/**\n * ThreePresenter - Main 3D Scene Presenter Component\n * \n * Manages the complete 3D viewing experience including model loading, rendering,\n * camera controls, lighting, and user interactions.\n * \n * @description\n * This class is responsible for:\n * - Loading and displaying 3D models from scene.json configuration\n * - Managing Three.js scene, camera, renderer, and controls\n * - Providing UI controls (visibility, lighting, camera reset, screenshots)\n * - Handling model transformations (position, rotation, scale)\n * - Supporting multiple 3D file formats (GLB, PLY, OBJ, etc.)\n * - Auto-centering and normalizing model sizes\n * \n * @example\n * ```typescript\n * const presenter = new ThreePresenter(mountElement);\n * await presenter.loadScene(sceneDescription);\n * presenter.setModelVisibility('model_id', false);\n * ```\n * \n * @see {@link /doc/SCENE_JSON_FORMAT.md} for scene.json format documentation\n */\nexport class ThreePresenter {\n  renderer: THREE.WebGLRenderer;\n  scene: THREE.Scene;\n  camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;\n  orthographicCamera: THREE.OrthographicCamera | null = null;\n  perspectiveCamera: THREE.PerspectiveCamera;\n  isOrthographic: boolean = false;\n  controls: any;\n  models: Record<string, THREE.Object3D> = {};  // Changed from meshes\n  currentScene: SceneDescription | null = null;\n  mount: HTMLDivElement;\n  ground: THREE.GridHelper | null = null;\n  homeButton: HTMLButtonElement;\n  lightButton: HTMLButtonElement;\n  lightPositionButton: HTMLButtonElement;\n  viewportGizmo: any = null;\n  envButton: HTMLButtonElement;\n  screenshotButton: HTMLButtonElement;\n  cameraButton: HTMLButtonElement;\n  annotationButton: HTMLButtonElement;\n  isPickingMode: boolean = false;\n  onPointPicked: ((point: [number, number, number]) => void) | null = null;\n  initialCameraPosition: THREE.Vector3 = new THREE.Vector3(0, 0, 2);\n  initialControlsTarget: THREE.Vector3 = new THREE.Vector3(0, 0, 0);\n  lightEnabled: boolean = true;\n  raycaster: THREE.Raycaster = new THREE.Raycaster();\n  mouse: THREE.Vector2 = new THREE.Vector2();\n  modelStats: Record<string, GeometryStats> = {};\n  sceneBBoxSize: THREE.Vector3 = new THREE.Vector3(2, 2, 2); // Store actual scene size for ground\n  \n  // File URL resolver for loading models\n  private fileUrlResolver: FileUrlResolver;\n  \n  // Loading progress callbacks\n  onLoadProgress?: (progress: LoadingProgress) => void;\n  onLoadComplete?: (modelId: string) => void;\n  onLoadError?: (modelId: string, error: Error) => void;\n  \n  // Managers\n  private annotationManager: AnnotationManager;\n  private cameraManager: CameraManager;\n  private lightingManager: LightingManager;\n  private modelLoader: ModelLoader;\n\n  constructor(mount: HTMLDivElement | string, fileUrlResolver?: FileUrlResolver) {\n    // Support both element and element ID\n    if (typeof mount === 'string') {\n      const element = document.getElementById(mount);\n      if (!element) {\n        throw new Error(`Element with ID \"${mount}\" not found`);\n      }\n      this.mount = element as HTMLDivElement;\n    } else {\n      this.mount = mount;\n    }\n    \n    this.scene = new THREE.Scene();\n    this.scene.background = new THREE.Color(0x404040);\n    const widthPx = this.mount.clientWidth;\n    const heightPx = this.mount.clientHeight;\n    const aspect = widthPx / heightPx;\n    \n    // Initialize file URL resolver (use StaticBaseUrlResolver with './assets' as default)\n    // This makes standalone examples work out-of-the-box\n    this.fileUrlResolver = fileUrlResolver || new StaticBaseUrlResolver('./assets');\n    \n    // Create camera manager\n    this.cameraManager = new CameraManager(aspect, {\n      fov: 40,\n      near: 0.1,\n      far: 1000,\n      frustumSize: 2,\n      initialPosition: new THREE.Vector3(0, 0, 2),\n      initialTarget: new THREE.Vector3(0, 0, 0)\n    });\n    \n    // Get cameras from manager\n    this.perspectiveCamera = this.cameraManager.getPerspectiveCamera();\n    this.orthographicCamera = this.cameraManager.getOrthographicCamera();\n    this.camera = this.cameraManager.getActiveCamera();\n    \n    this.renderer = new THREE.WebGLRenderer({ antialias: true });\n    this.renderer.setSize(widthPx, heightPx);\n    this.renderer.toneMapping = THREE.ACESFilmicToneMapping;\n    this.renderer.toneMappingExposure = 1.0;\n    this.mount.appendChild(this.renderer.domElement);\n    \n    // Initialize annotation manager\n    this.annotationManager = new AnnotationManager(this.scene, {\n      color: 0xffff00,\n      selectedColor: 0xffff66,\n      markerSize: 10\n    });\n    \n    // Load environment map\n    this.loadEnvironmentMap();\n\n    // Create UI controls using UIControlsBuilder\n    // All buttons are hidden by default - use setButtonVisible() to show them\n    const buttonConfigs: ButtonConfig[] = [\n      {\n        id: 'home',\n        icon: 'bi-house',\n        title: 'Reset camera view',\n        onClick: () => this.resetCamera(),\n        visible: false\n      },\n      {\n        id: 'light',\n        icon: 'bi-lightbulb-fill',\n        title: 'Toggle lighting',\n        onClick: () => this.toggleLight(),\n        visible: false\n      },\n      {\n        id: 'lightPosition',\n        icon: 'bi-brightness-high', // Will be overridden by customHTML\n        customHTML: `\n          <div style=\"position: relative; width: 16px; height: 16px;\">\n            <i class=\"bi bi-brightness-high\" style=\"position: absolute; top: -10px; left: -4px; font-size: 24px;\"></i>\n            <i class=\"bi bi-arrows-move\" style=\"position: absolute; font-size: 32px; top: -16px; left: -8px;\"></i>\n          </div>\n        `,\n        title: 'Position headlight',\n        onClick: () => {}, // TODO: Add light positioning functionality\n        visible: false\n      },\n      {\n        id: 'env',\n        icon: 'bi-globe',\n        title: 'Toggle environment lighting',\n        onClick: () => this.toggleEnvLighting(),\n        visible: false\n      },\n      {\n        id: 'screenshot',\n        icon: 'bi-camera',\n        title: 'Take screenshot',\n        onClick: () => this.takeScreenshot(),\n        visible: false\n      },\n      {\n        id: 'camera',\n        icon: 'bi-box',\n        title: 'Toggle orthographic/perspective',\n        onClick: () => this.toggleCameraMode(),\n        visible: false\n      },\n      {\n        id: 'annotation',\n        icon: 'bi-pencil',\n        title: 'Add annotation',\n        onClick: () => this.togglePickingMode(),\n        visible: false\n      }\n    ];\n\n    const controlsBuilder = new UIControlsBuilder();\n    const uiControls = controlsBuilder\n      .setContainer({\n        position: 'top-left',\n        direction: 'vertical',\n        gap: 'gap-2',\n        zIndex: '1000'\n      })\n      .addButtons(buttonConfigs)\n      .build();\n\n    // Store button references\n    this.homeButton = uiControls.buttons.get('home')!;\n    this.lightButton = uiControls.buttons.get('light')!;\n    this.lightPositionButton = uiControls.buttons.get('lightPosition')!;\n    this.envButton = uiControls.buttons.get('env')!;\n    this.screenshotButton = uiControls.buttons.get('screenshot')!;\n    this.cameraButton = uiControls.buttons.get('camera')!;\n    this.annotationButton = uiControls.buttons.get('annotation')!;\n\n    // Append UI controls to mount\n    this.mount.style.position = this.mount.style.position || 'relative'; // ensure mount positioned for absolute children\n    this.mount.appendChild(uiControls.container);\n\n\n    // Lighting setup\n    this.lightingManager = new LightingManager(this.scene, {\n      ambientIntensity: 0.1,\n      headLightIntensity: 0.9,\n      lightColor: 0xffffff,\n      initialOffset: new THREE.Vector2(0, 0)\n    });\n    \n    // Model loading setup\n    this.modelLoader = new ModelLoader({\n      dracoDecoderPath: 'https://www.gstatic.com/draco/versioned/decoders/1.5.6/',\n      autoComputeNormals: true,\n      defaultMaterial: {\n        color: 0xdddddd,\n        flatShading: true\n      }\n    });\n    \n    // Animation loop\n    this.animate = this.animate.bind(this);\n    this.animate();\n    // Resize handler\n    this.handleResize = this.handleResize.bind(this);\n    window.addEventListener('resize', this.handleResize);\n    // Double-click handler for recentering\n    this.handleDoubleClick = this.handleDoubleClick.bind(this);\n    this.renderer.domElement.addEventListener('dblclick', this.handleDoubleClick);\n    // Click handler for annotation selection\n    this.handleClick = this.handleClick.bind(this);\n    this.renderer.domElement.addEventListener('click', this.handleClick);\n  }\n\n  dispose() {\n    window.removeEventListener('resize', this.handleResize);\n    this.renderer.domElement.removeEventListener('dblclick', this.handleDoubleClick);\n    this.renderer.domElement.removeEventListener('click', this.handleClick);\n    \n    // Dispose managers\n    this.annotationManager.dispose();\n    this.lightingManager.dispose();\n    this.modelLoader.dispose();\n    \n    this.renderer.dispose();\n    if (this.renderer.domElement.parentNode) {\n      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);\n    }\n    if (this.homeButton.parentNode) {\n      this.homeButton.parentNode.removeChild(this.homeButton);\n    }\n    if (this.lightButton.parentNode) {\n      this.lightButton.parentNode.removeChild(this.lightButton);\n    }\n    if (this.lightPositionButton.parentNode) {\n      this.lightPositionButton.parentNode.removeChild(this.lightPositionButton);\n    }\n    if (this.envButton.parentNode) {\n      this.envButton.parentNode.removeChild(this.envButton);\n    }\n    if (this.screenshotButton.parentNode) {\n      this.screenshotButton.parentNode.removeChild(this.screenshotButton);\n    }\n    if (this.annotationButton.parentNode) {\n      this.annotationButton.parentNode.removeChild(this.annotationButton);\n    }\n    if (this.viewportGizmo && this.viewportGizmo.dispose) {\n      this.viewportGizmo.dispose();\n      this.viewportGizmo = null;\n    }\n  }\n\n  handleResize() {\n    const w = this.mount.clientWidth;\n    const h = this.mount.clientHeight;\n    \n    this.renderer.setSize(w, h);\n    \n    // Use camera manager to handle resize for both cameras\n    this.cameraManager.handleResize(w, h);\n    \n    // Update camera reference\n    this.camera = this.cameraManager.getActiveCamera();\n    \n    if (this.controls) this.controls.update(); \n    if (this.viewportGizmo) this.viewportGizmo.update();\n  }\n\n  /**\n   * Handle double-click on the canvas to recenter the camera on the clicked point\n   */\n  handleDoubleClick(event: MouseEvent) {\n    if (!this.controls) return;\n\n    // Calculate mouse position in normalized device coordinates (-1 to +1)\n    const rect = this.renderer.domElement.getBoundingClientRect();\n    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n    // Update raycaster\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n\n    // Get all model objects for raycasting\n    const modelObjects: THREE.Object3D[] = [];\n    Object.values(this.models).forEach(model => {\n      // Recursively collect all meshes in the model\n      model.traverse((child) => {\n        if (child instanceof THREE.Mesh) {\n          modelObjects.push(child);\n        }\n      });\n    });\n\n    // Check for intersections\n    const intersects = this.raycaster.intersectObjects(modelObjects, false);\n\n    if (intersects.length > 0) {\n      const intersectionPoint = intersects[0].point;\n      \n      // If in picking mode, notify callback and exit picking mode\n      if (this.isPickingMode) {\n        const coords: [number, number, number] = [\n          intersectionPoint.x,\n          intersectionPoint.y,\n          intersectionPoint.z\n        ];\n        console.log('üìç Picked 3D point:', coords.map(v => v.toFixed(4)));\n        \n        // Call the callback if set\n        if (this.onPointPicked) {\n          this.onPointPicked(coords);\n        }\n        \n        this.exitPickingMode();\n        return;\n      }\n      \n      // Otherwise, recenter camera on point\n      console.log('üéØ Recentering camera on point:', intersectionPoint);\n      this.animateCameraTarget(intersectionPoint);\n    }\n  }\n\n  /**\n   * Handle single click for annotation selection\n   */\n  handleClick(event: MouseEvent) {\n    // Don't handle clicks while in picking mode\n    if (this.annotationManager.isPickingMode()) return;\n    \n    // Calculate mouse position in normalized device coordinates\n    const rect = this.renderer.domElement.getBoundingClientRect();\n    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n    // Update raycaster\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n\n    // Check for intersections with annotation markers\n    const markerObjects = this.annotationManager.getAllMarkers();\n    const intersects = this.raycaster.intersectObjects(markerObjects, false);\n\n    if (intersects.length > 0) {\n      // Find which annotation was clicked\n      const clickedMarker = intersects[0].object as THREE.Mesh;\n      const clickedAnnotationId = this.annotationManager.getAnnotationIdFromMarker(clickedMarker);\n\n      if (clickedAnnotationId) {\n        // Toggle selection with Ctrl/Cmd for multi-select, otherwise single select\n        if (event.ctrlKey || event.metaKey) {\n          this.annotationManager.toggleSelection(clickedAnnotationId);\n        } else {\n          this.annotationManager.select([clickedAnnotationId], false); // Replace selection\n        }\n      }\n    } else {\n      // Clicked on empty space - clear selection if not using modifier keys\n      if (!event.ctrlKey && !event.metaKey) {\n        this.annotationManager.clearSelection();\n      }\n    }\n  }\n\n  /**\n   * Toggle picking mode for annotation placement\n   */\n  togglePickingMode() {\n    if (this.isPickingMode) {\n      this.exitPickingMode();\n    } else {\n      this.enterPickingMode();\n    }\n  }\n\n  /**\n   * Enter picking mode\n   */\n  private enterPickingMode() {\n    this.isPickingMode = true;\n    this.renderer.domElement.style.cursor = 'crosshair';\n    this.annotationButton.style.backgroundColor = '#0d6efd'; // Bootstrap primary blue\n    this.annotationButton.style.color = 'white';\n    console.log('‚úèÔ∏è Entered picking mode - double-click on model to pick a point');\n  }\n\n  /**\n   * Exit picking mode\n   */\n  private exitPickingMode() {\n    this.isPickingMode = false;\n    this.renderer.domElement.style.cursor = 'auto';\n    this.annotationButton.style.backgroundColor = '';\n    this.annotationButton.style.color = '';\n    console.log('‚úÖ Exited picking mode');\n  }\n\n  /**\n   * Smoothly animate the camera controls target to a new position\n   */\n  private animateCameraTarget(targetPosition: THREE.Vector3) {\n    if (!this.controls) return;\n\n    const startTarget = this.controls.target.clone();\n    const endTarget = targetPosition.clone();\n    const duration = 500; // milliseconds\n    const startTime = performance.now();\n\n    const animate = () => {\n      const elapsed = performance.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      \n      // Ease-out cubic for smooth deceleration\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\n\n      // Interpolate between start and end\n      this.controls.target.lerpVectors(startTarget, endTarget, easeProgress);\n      this.controls.update();\n\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n\n    animate();\n  }\n\n  animate() {\n    requestAnimationFrame(this.animate);\n    if (this.controls) this.controls.update();\n    \n    // Update head light position to follow camera\n    const target = (this.controls && this.controls.target) \n      ? this.controls.target \n      : new THREE.Vector3(0, 0, 0);\n    this.lightingManager.updateHeadLight(this.camera, target);\n    \n    // Update annotation marker scales to maintain constant screen space size\n    this.annotationManager.updateMarkerScales(this.camera, this.renderer.domElement.clientHeight);\n    \n    // Update Nexus objects for multiresolution streaming\n    this.scene.traverse((object: THREE.Object3D) => {\n      if ((object as any).update && typeof (object as any).update === 'function') {\n        // NexusObject has an update method that needs the camera\n        (object as any).update(this.camera);\n      }\n    });\n    \n    this.renderer.render(this.scene, this.camera);\n\n    // Render viewport gizmo if present\n    if (this.viewportGizmo && typeof this.viewportGizmo.render === 'function') {\n      this.viewportGizmo.render();\n    }\n  }\n\n  /**\n   * Load a new scene description\n   * @param sceneDesc Scene description\n   * @param preserveCamera If true, keeps current camera position instead of reframing\n   */\n  async loadScene(sceneDesc: SceneDescription, preserveCamera: boolean = false): Promise<void> {\n    try {\n      // Save current camera state if preserving\n      let savedCameraPos: THREE.Vector3 | null = null;\n      let savedCameraTarget: THREE.Vector3 | null = null;\n      if (preserveCamera && this.controls) {\n        savedCameraPos = this.camera.position.clone();\n        savedCameraTarget = this.controls.target.clone();\n        console.log('üì∑ Preserving camera position during scene reload');\n      }\n      \n      this.currentScene = sceneDesc;\n\n      // Clear existing scene\n      this.clearScene();\n\n      // Apply environment settings\n      if (sceneDesc.environment) {\n        this.applyEnvironmentSettings(sceneDesc.environment);\n      }\n\n      // Setup controls if enabled\n      if (sceneDesc.enableControls !== false) {\n        await this.setupControls();\n      }\n\n      // Load all models\n      if (sceneDesc.models && sceneDesc.models.length > 0) {\n        await this.loadAllModels(sceneDesc.models);\n        \n        if (!preserveCamera) {\n          this.frameScene();\n        } else {\n          // Update scene bbox size for ground without reframing camera\n          const sceneBBox = new THREE.Box3();\n          Object.values(this.models).forEach(m => sceneBBox.expandByObject(m));\n          const size = sceneBBox.getSize(new THREE.Vector3());\n          this.sceneBBoxSize.copy(size);\n        }\n        \n        // Recreate ground with correct size after framing scene\n        if (sceneDesc.environment?.showGround) {\n          this.removeGround();\n          this.addGround();\n        }\n      }\n      \n      // Restore camera position if preserved\n      if (preserveCamera && savedCameraPos && savedCameraTarget && this.controls) {\n        this.camera.position.copy(savedCameraPos);\n        this.controls.target.copy(savedCameraTarget);\n        this.controls.update();\n        console.log('üì∑ Camera position restored after scene reload');\n      }\n\n      // Render annotations if present\n      if (sceneDesc.annotations && sceneDesc.annotations.length > 0) {\n        this.annotationManager.render(sceneDesc.annotations);\n      }\n\n      console.log('‚úÖ Scene loaded successfully');\n    } catch (error) {\n      console.error('‚ùå Failed to load scene:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all models from the scene\n   */\n  private clearScene(): void {\n    Object.values(this.models).forEach(model => {\n      this.scene.remove(model);\n    });\n    this.models = {};\n  }\n\n  /**\n   * Apply transforms from ModelDefinition to a loaded Object3D\n   * - position: [x,y,z]\n   * - rotation: [x,y,z] in radians or degrees (auto-detect)\n   * - scale: single number or [x,y,z]\n   */\n  private applyTransforms(model: THREE.Object3D, def: ModelDefinition) {\n    // Position\n    if (def.position && def.position.length === 3) {\n      model.position.set(def.position[0], def.position[1], def.position[2]);\n    }\n\n    // Rotation - prefer explicit units (def.rotationUnits -> scene rotationUnits), otherwise auto-detect\n    if (def.rotation && def.rotation.length === 3) {\n      const r = def.rotation;\n      const sceneUnits = this.currentScene?.rotationUnits;\n      const units = def.rotationUnits || sceneUnits || null; // 'deg' | 'rad' | null\n      let rx = r[0], ry = r[1], rz = r[2];\n      if (units === 'deg') {\n        const degToRad = Math.PI / 180;\n        rx = r[0] * degToRad;\n        ry = r[1] * degToRad;\n        rz = r[2] * degToRad;\n      } else if (units === 'rad') {\n        // use as-is\n      } else {\n        // auto-detect degrees if values are large (> 2œÄ)\n        const maxAbs = Math.max(Math.abs(r[0]), Math.abs(r[1]), Math.abs(r[2]));\n        const twoPi = Math.PI * 2;\n        if (maxAbs > twoPi + 0.0001) {\n          const degToRad = Math.PI / 180;\n          rx = r[0] * degToRad;\n          ry = r[1] * degToRad;\n          rz = r[2] * degToRad;\n        }\n      }\n      model.rotation.set(rx, ry, rz);\n    }\n\n    // Scale - accept number or vec3\n    if (def.scale !== undefined) {\n      if (typeof def.scale === 'number') {\n        model.scale.set(def.scale, def.scale, def.scale);\n      } else if (Array.isArray(def.scale) && def.scale.length === 3) {\n        model.scale.set(def.scale[0], def.scale[1], def.scale[2]);\n      }\n    }\n  }\n\n  /**\n   * Apply environment settings (ground, background)\n   */\n  private applyEnvironmentSettings(env: any): void {\n    // Handle ground grid\n    this.removeGround();\n    if (env.showGround) {\n      this.addGround();\n    }\n    \n    // Handle background color\n    if (env.background) {\n      this.scene.background = new THREE.Color(env.background);\n    }\n\n    // Handle head light offset (stored in degrees in scene JSON)\n    if (env.headLightOffset && Array.isArray(env.headLightOffset) && env.headLightOffset.length >= 2) {\n      this.lightingManager.setHeadLightOffsetFromDegrees(\n        env.headLightOffset[0] || 0,\n        env.headLightOffset[1] || 0\n      );\n      // Immediately apply so the headlight is positioned correctly\n      const target = this.controls?.target || new THREE.Vector3(0, 0, 0);\n      this.lightingManager.updateHeadLight(this.camera, target);\n    }\n  }\n\n  /**\n   * Setup orbit controls and viewport gizmo\n   */\n  private async setupControls(): Promise<void> {\n    if (this.controls) return; // Already setup\n    \n    const { OrbitControls } = await import('three/addons/controls/OrbitControls.js');\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.controls.enableDamping = true;\n    this.controls.dampingFactor = 0.05;\n    this.controls.screenSpacePanning = true;\n    // Initial limits - will be updated after scene is loaded\n    this.controls.minDistance = 0.1;\n    this.controls.maxDistance = 1000;\n    this.controls.target.set(0, 0, 0);\n    this.controls.update();\n\n    // Create and attach ViewportGizmo (dynamically import to avoid bundling it always)\n    if (!this.viewportGizmo) {\n      try {\n        const { ViewportGizmo } = await import('three-viewport-gizmo');\n        this.viewportGizmo = new ViewportGizmo(this.camera, this.renderer, {\n          container: this.mount,\n          size: 80\n        });\n        if (this.viewportGizmo.attachControls) this.viewportGizmo.attachControls(this.controls);\n        console.log('‚úÖ ViewportGizmo created and attached to controls');\n      } catch (err) {\n        console.warn('‚ö†Ô∏è Failed to load viewport gizmo dynamically:', err);\n      }\n    }\n  }\n\n  /**\n   * Load all models from the scene description\n   */\n  private async loadAllModels(modelDefs: ModelDefinition[]): Promise<void> {\n    const loadPromises = modelDefs.map(modelDef => this.loadModel(modelDef));\n    await Promise.all(loadPromises);\n  }\n\n  /**\n   * Load a single model\n   */\n  private async loadModel(modelDef: ModelDefinition): Promise<void> {\n    // Use the file URL resolver to get the full URL\n    const projectId = this.currentScene?.projectId;\n    const fullUrl = this.fileUrlResolver.resolve(modelDef.file, { projectId });\n    \n    console.log(`Loading model ${modelDef.id} from ${fullUrl}`);\n    \n    try {\n      // Notify loading started\n      this.onLoadProgress?.({\n        modelId: modelDef.id,\n        fileName: modelDef.file,\n        loaded: 0,\n        total: 0,\n        percentage: 0,\n        status: 'loading'\n      });\n      \n      const model = await this.loadModelFile(fullUrl, modelDef);\n      \n      // Apply transforms (position, rotation, scale)\n      this.applyTransforms(model, modelDef);\n      if (modelDef.visible !== undefined) {\n        model.visible = modelDef.visible;\n      }\n      \n      // Calculate and store model statistics\n      this.modelStats[modelDef.id] = calculateObjectStats(model);\n      console.log(`üìä Model ${modelDef.id} stats:`, this.modelStats[modelDef.id]);\n      \n      // Store and add to scene\n      this.models[modelDef.id] = model;\n      this.scene.add(model);\n      \n      console.log(`‚úÖ Loaded model ${modelDef.id}`);\n      \n      // Notify completion\n      this.onLoadProgress?.({\n        modelId: modelDef.id,\n        fileName: modelDef.file,\n        loaded: 0,\n        total: 0,\n        percentage: 100,\n        status: 'complete'\n      });\n      this.onLoadComplete?.(modelDef.id);\n    } catch (error) {\n      console.error(`‚ùå Failed to load model ${modelDef.id}:`, error);\n      \n      // Notify error\n      this.onLoadProgress?.({\n        modelId: modelDef.id,\n        fileName: modelDef.file,\n        loaded: 0,\n        total: 0,\n        percentage: 0,\n        status: 'error'\n      });\n      this.onLoadError?.(modelDef.id, error as Error);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Load a model file based on its extension\n   */\n  private async loadModelFile(url: string, modelDef: ModelDefinition): Promise<THREE.Object3D> {\n    // Use the ModelLoader to handle format detection and loading\n    const materialOverrides = modelDef.material ? {\n      color: modelDef.material.color ? parseInt(modelDef.material.color.replace('#', ''), 16) : undefined,\n      flatShading: modelDef.material.flatShading,\n      metalness: modelDef.material.metalness,\n      roughness: modelDef.material.roughness\n    } : undefined;\n\n    // Create progress callback\n    const onProgress = (loaded: number, total: number, percentage: number) => {\n      this.onLoadProgress?.({\n        modelId: modelDef.id,\n        fileName: modelDef.file,\n        loaded,\n        total,\n        percentage,\n        status: 'loading'\n      });\n    };\n\n    const result = await this.modelLoader.loadFromUrl(url, materialOverrides, onProgress);\n    console.log(`üì¶ Loaded ${result.format.toUpperCase()} model (${(result.byteSize / 1024).toFixed(2)} KB)`);\n    \n    return result.object;\n  }\n\n  /**\n   * Frame the scene - position models and camera without scaling\n   * Models without predefined positions are translated so:\n   * - Bottom of bbox is at y=0\n   * - Center of X and Z axes are at origin\n   * Camera is positioned at appropriate distance based on scene size\n   */\n  private frameScene(): void {\n    const allModels = Object.values(this.models);\n    if (allModels.length === 0) return;\n    \n    // Calculate scene bounding box to determine camera position and ground size\n    const sceneBBox = new THREE.Box3();\n    allModels.forEach(m => sceneBBox.expandByObject(m));\n    const size = sceneBBox.getSize(new THREE.Vector3());\n    const maxDim = Math.max(size.x, size.y, size.z);\n    \n    console.log('Scene bounding box size (original):', size, 'maxDim:', maxDim);\n    \n    // Store scene size for ground sizing\n    this.sceneBBoxSize.copy(size);\n    \n    if (maxDim > 0) {\n      const center = sceneBBox.getCenter(new THREE.Vector3());\n      \n      // Calculate translation needed to center scene\n      const offsetX = -center.x;\n      const offsetZ = -center.z;\n      const offsetY = -sceneBBox.min.y;\n      \n      // Apply automatic positioning only to models without predefined positions\n      allModels.forEach((model, idx) => {\n        if (this.currentScene?.models) {\n          const modelDef = this.currentScene.models[idx];\n          if (modelDef) {\n            // Only apply automatic positioning if position is not already defined\n            if (!modelDef.position || modelDef.position.length !== 3) {\n              const translation = new THREE.Vector3(offsetX, offsetY, offsetZ);\n              model.position.add(translation);\n              \n              // Store the computed position in the model definition (rounded to 3 decimals)\n              const pos = model.position;\n              modelDef.position = [\n                parseFloat(pos.x.toFixed(3)),\n                parseFloat(pos.y.toFixed(3)),\n                parseFloat(pos.z.toFixed(3))\n              ];\n              console.log(`üìç Model ${modelDef.id} auto-positioned to:`, modelDef.position);\n            } else {\n              console.log(`üìç Model ${modelDef.id} using predefined position:`, modelDef.position);\n            }\n          }\n        }\n      });\n      \n      // Position camera at appropriate distance based on scene size\n      // Use a distance that fits the entire scene in view\n      const fov = this.perspectiveCamera.fov * (Math.PI / 180); // Convert to radians\n      const cameraDistance = (maxDim / 2) / Math.tan(fov / 2);\n      const targetY = size.y * 0.5;\n      \n      // Add some padding (1.2x distance)\n      const finalDistance = cameraDistance * 1.2;\n      \n      this.camera.position.set(0, targetY, finalDistance);\n      if (this.controls) {\n        this.controls.target.set(0, targetY, 0);\n        // Set reasonable zoom limits based on scene size\n        this.controls.minDistance = maxDim * 0.1;\n        this.controls.maxDistance = maxDim * 10;\n        this.controls.update();\n      }\n      \n      // Update orthographic camera frustum if it exists\n      if (this.orthographicCamera) {\n        const aspect = this.mount.clientWidth / this.mount.clientHeight;\n        const frustumHeight = maxDim;\n        const frustumWidth = frustumHeight * aspect;\n        this.orthographicCamera.left = -frustumWidth / 2;\n        this.orthographicCamera.right = frustumWidth / 2;\n        this.orthographicCamera.top = frustumHeight / 2;\n        this.orthographicCamera.bottom = -frustumHeight / 2;\n        this.orthographicCamera.position.set(0, targetY, finalDistance);\n        this.orthographicCamera.updateProjectionMatrix();\n      }\n      \n      // Store initial position\n      this.initialCameraPosition.copy(this.camera.position);\n      this.initialControlsTarget.set(0, targetY, 0);\n      \n      // Update camera manager's initial values\n      this.cameraManager.setInitialPosition(this.camera.position);\n      this.cameraManager.setInitialTarget(new THREE.Vector3(0, targetY, 0));\n      \n      console.log(`üì∑ Camera positioned at distance ${finalDistance.toFixed(2)}, target height ${targetY.toFixed(2)}`);\n    }\n  }\n\n  /**\n   * Get current presenter state (for saving/persistence)\n   */\n  getState(): PresenterState {\n    return {\n      camera: {\n        position: this.camera.position.toArray() as [number, number, number],\n        target: this.controls?.target.toArray() as [number, number, number] || [0, 0, 0],\n        fov: this.camera instanceof THREE.PerspectiveCamera ? this.camera.fov : 45,\n      },\n      rendering: {\n        headLightEnabled: this.lightEnabled,\n        envLightingEnabled: this.lightingManager.isEnvironmentLightingEnabled(),\n      },\n      modelVisibility: this.getModelVisibility(),\n    };\n  }\n\n  /**\n   * Apply transformations to a specific model without saving to scene\n   * Useful for live preview while editing\n   */\n  applyModelTransform(\n    modelId: string,\n    position?: [number, number, number] | null,\n    rotation?: [number, number, number] | null,\n    scale?: number | [number, number, number] | null\n  ): void {\n    const model = this.models[modelId];\n    if (!model) {\n      console.warn(`Model ${modelId} not found`);\n      return;\n    }\n\n    // Apply position\n    if (position && position.length === 3) {\n      model.position.set(position[0], position[1], position[2]);\n    }\n\n    // Apply rotation (always in radians for Three.js)\n    if (rotation && rotation.length === 3) {\n      model.rotation.set(rotation[0], rotation[1], rotation[2]);\n    }\n\n    // Apply scale\n    if (scale !== undefined && scale !== null) {\n      if (typeof scale === 'number') {\n        model.scale.set(scale, scale, scale);\n      } else if (Array.isArray(scale) && scale.length === 3) {\n        model.scale.set(scale[0], scale[1], scale[2]);\n      }\n    }\n  }\n\n  /**\n   * Restore presenter state (from saved/persistence)\n   */\n  setState(state: PresenterState): void {\n    // Restore camera\n    this.camera.position.fromArray(state.camera.position);\n    if (this.controls) {\n      this.controls.target.fromArray(state.camera.target);\n      this.controls.update();\n    }\n    if (state.camera.fov && this.camera instanceof THREE.PerspectiveCamera) {\n      this.camera.fov = state.camera.fov;\n      this.camera.updateProjectionMatrix();\n    }\n    \n    // Restore rendering settings\n    this.lightEnabled = state.rendering.headLightEnabled;\n    this.lightingManager.setHeadLightEnabled(this.lightEnabled);\n    this.lightButton.innerHTML = this.lightEnabled ? '<i class=\"bi bi-lightbulb-fill\"></i>' : '<i class=\"bi bi-lightbulb\"></i>';\n    \n    this.lightingManager.setEnvironmentLightingEnabled(state.rendering.envLightingEnabled);\n    this.envButton.innerHTML = state.rendering.envLightingEnabled ? '<i class=\"bi bi-globe\"></i>' : '<i class=\"bi bi-circle\"></i>';\n    \n    // Restore model visibility\n    for (const [modelId, visible] of Object.entries(state.modelVisibility)) {\n      this.setModelVisibility(modelId, visible);\n    }\n  }\n\n  /**\n   * Set visibility of a model by ID\n   */\n  setModelVisibility(modelId: string, visible: boolean): void {\n    const model = this.models[modelId];\n    if (model) {\n      model.visible = visible;\n      console.log(`üëÅÔ∏è Model '${modelId}' visibility set to ${visible}`);\n    } else {\n      console.warn(`‚ö†Ô∏è Model '${modelId}' not found in loaded models. Available models:`, Object.keys(this.models));\n    }\n  }\n\n  /**\n   * Get visibility of a specific model\n   */\n  getModelVisibilityById(modelId: string): boolean {\n    const model = this.models[modelId];\n    return model ? model.visible : false;\n  }\n\n  /**\n   * Get visibility of all models\n   */\n  private getModelVisibility(): Record<string, boolean> {\n    const visibility: Record<string, boolean> = {};\n    for (const [id, model] of Object.entries(this.models)) {\n      visibility[id] = model.visible;\n    }\n    return visibility;\n  }\n\n  /**\n   * Get the annotation manager instance for direct access to annotation API\n   * @returns The AnnotationManager instance\n   */\n  getAnnotationManager(): AnnotationManager {\n    return this.annotationManager;\n  }\n\n  /**\n   * Set background color without reloading the scene\n   * @param color Hex color string (e.g., '#404040')\n   */\n  setBackgroundColor(color: string): void {\n    this.scene.background = new THREE.Color(color);\n    // Update currentScene if it exists\n    if (this.currentScene && this.currentScene.environment) {\n      this.currentScene.environment.background = color;\n    }\n    console.log('üé® Background color updated to:', color);\n  }\n\n  /**\n   * Toggle ground visibility without reloading the scene\n   * @param visible Whether the ground should be visible\n   */\n  setGroundVisible(visible: boolean): void {\n    if (visible && !this.ground) {\n      this.addGround();\n    } else if (!visible && this.ground) {\n      this.removeGround();\n    }\n    // Update currentScene if it exists\n    if (this.currentScene && this.currentScene.environment) {\n      this.currentScene.environment.showGround = visible;\n    }\n    console.log('üåç Ground visibility set to:', visible);\n  }\n\n  /**\n   * Set head light offset without reloading the scene\n   * @param thetaDeg Horizontal angle in degrees\n   * @param phiDeg Vertical angle in degrees\n   */\n  setHeadLightOffset(thetaDeg: number, phiDeg: number): void {\n    this.lightingManager.setHeadLightOffsetFromDegrees(thetaDeg, phiDeg);\n    const target = this.controls?.target || new THREE.Vector3(0, 0, 0);\n    this.lightingManager.updateHeadLight(this.camera, target);\n    // Update currentScene if it exists\n    if (this.currentScene && this.currentScene.environment) {\n      if (!this.currentScene.environment.headLightOffset) {\n        this.currentScene.environment.headLightOffset = [0, 0];\n      }\n      this.currentScene.environment.headLightOffset[0] = thetaDeg;\n      this.currentScene.environment.headLightOffset[1] = phiDeg;\n    }\n    console.log('üí° Head light offset updated to:', thetaDeg, phiDeg);\n  }\n\n  resetCamera() {\n    // Use camera manager to reset camera\n    this.cameraManager.resetCamera(this.controls);\n    console.log('üì∑ Camera view reset to home position');\n  }\n\n  toggleLight() {\n    this.lightEnabled = this.lightingManager.toggleHeadLight();\n    this.lightButton.innerHTML = this.lightEnabled ? '<i class=\"bi bi-lightbulb-fill\"></i>' : '<i class=\"bi bi-lightbulb\"></i>';\n    console.log(`üí° Lighting ${this.lightEnabled ? 'enabled' : 'disabled'}`);\n  }\n\n  toggleEnvLighting() {\n    const enabled = this.lightingManager.toggleEnvironmentLighting();\n    this.envButton.innerHTML = enabled ? '<i class=\"bi bi-globe\"></i>' : '<i class=\"bi bi-circle\"></i>';\n    console.log(`üåç Environment lighting ${enabled ? 'enabled' : 'disabled'}`);\n  }\n\n  /**\n   * Show or hide the annotation button\n   */\n  setAnnotationButtonVisible(visible: boolean) {\n    this.annotationButton.style.display = visible ? 'flex' : 'none';\n    // Exit picking mode when hiding the button\n    if (!visible && this.isPickingMode) {\n      this.exitPickingMode();\n    }\n  }\n\n  /**\n   * Show or hide a specific UI button\n   * @param buttonName - Name of the button: 'home', 'light', 'lightPosition', 'env', 'screenshot', 'camera', 'annotation'\n   * @param visible - true to show, false to hide\n   */\n  setButtonVisible(buttonName: string, visible: boolean) {\n    const buttonMap: { [key: string]: HTMLButtonElement } = {\n      home: this.homeButton,\n      light: this.lightButton,\n      lightPosition: this.lightPositionButton,\n      env: this.envButton,\n      screenshot: this.screenshotButton,\n      camera: this.cameraButton,\n      annotation: this.annotationButton\n    };\n\n    const button = buttonMap[buttonName];\n    if (button) {\n      button.style.display = visible ? 'flex' : 'none';\n      // Exit picking mode when hiding annotation button\n      if (buttonName === 'annotation' && !visible && this.isPickingMode) {\n        this.exitPickingMode();\n      }\n    } else {\n      console.warn(`Unknown button name: ${buttonName}. Valid options: ${Object.keys(buttonMap).join(', ')}`);\n    }\n  }\n\n  /**\n   * Show or hide all UI buttons at once\n   */\n  setAllButtonsVisible(visible: boolean) {\n    this.homeButton.style.display = visible ? 'flex' : 'none';\n    this.lightButton.style.display = visible ? 'flex' : 'none';\n    this.lightPositionButton.style.display = visible ? 'flex' : 'none';\n    this.envButton.style.display = visible ? 'flex' : 'none';\n    this.screenshotButton.style.display = visible ? 'flex' : 'none';\n    this.cameraButton.style.display = visible ? 'flex' : 'none';\n    this.annotationButton.style.display = visible ? 'flex' : 'none';\n    \n    if (!visible && this.isPickingMode) {\n      this.exitPickingMode();\n    }\n  }\n\n  toggleCameraMode() {\n    if (!this.orthographicCamera) return;\n    \n    // Use camera manager to toggle camera mode\n    this.camera = this.cameraManager.toggleCameraMode(this.controls);\n    this.isOrthographic = this.cameraManager.isOrthographicMode();\n    \n    // Update button opacity\n    if (this.isOrthographic) {\n      this.cameraButton.style.opacity = '0.7';\n      console.log('üì¶ Switched to orthographic camera');\n    } else {\n      this.cameraButton.style.opacity = '1';\n      console.log('üìê Switched to perspective camera');\n    }\n    \n    // Dispose and recreate viewport gizmo with the new camera\n    this.recreateViewportGizmo();\n  }\n\n  async recreateViewportGizmo() {\n    // Dispose existing gizmo\n    if (this.viewportGizmo && this.viewportGizmo.dispose) {\n      try {\n        this.viewportGizmo.dispose();\n        console.log('üóëÔ∏è Disposed old viewport gizmo');\n      } catch (err) {\n        console.warn('Failed to dispose viewport gizmo:', err);\n      }\n      this.viewportGizmo = null;\n    }\n    \n    // Create new gizmo with current camera\n    try {\n      const { ViewportGizmo } = await import('three-viewport-gizmo');\n      this.viewportGizmo = new ViewportGizmo(this.camera, this.renderer, {\n        container: this.mount,\n        size: 80\n      });\n      if (this.viewportGizmo.attachControls && this.controls) {\n        this.viewportGizmo.attachControls(this.controls);\n      }\n      console.log('‚úÖ Recreated viewport gizmo with new camera');\n    } catch (err) {\n      console.warn('‚ö†Ô∏è Failed to recreate viewport gizmo:', err);\n    }\n  }\n\n  takeScreenshot() {\n    // Render the current frame to ensure we have the latest state\n    this.renderer.render(this.scene, this.camera);\n    \n    // Get the canvas data as a data URL (PNG format)\n    const dataURL = this.renderer.domElement.toDataURL('image/png');\n    \n    // Create a temporary link element to trigger download\n    const link = document.createElement('a');\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);\n    link.download = `screenshot-${timestamp}.png`;\n    link.href = dataURL;\n    link.click();\n    \n    console.log('üì∏ Screenshot captured and downloaded');\n  }\n\n  /**\n   * Calculate triangle and vertex counts for a loaded model\n   * @param modelId - The ID of the model to analyze\n   * @returns Object with triangle and vertex counts, or null if model not found\n   */\n  getModelStats(modelId: string): { triangles: number; vertices: number; bbox: { x: number; y: number; z: number }; textures: { count: number; dimensions: Array<{ width: number; height: number }> } } | null {\n    return this.modelStats[modelId] || null;\n  }\n\n  private addGround() {\n    // Create a grid helper at y = 0, sized based on actual scene dimensions\n    // GridHelper(size, divisions, colorCenterLine, colorGrid)\n    const maxDim = Math.max(this.sceneBBoxSize.x, this.sceneBBoxSize.z);\n    const size = maxDim * 2; // Make ground 2x the scene size for context\n    const divisions = Math.max(10, Math.min(50, Math.floor(size / 0.1))); // Adaptive divisions\n    const colorCenterLine = 0xdddddd;\n    const colorGrid = 0x888888;\n    \n    this.ground = new THREE.GridHelper(size, divisions, colorCenterLine, colorGrid);\n    // GridHelper is created in XZ plane by default, which is what we want (y=0)\n    this.scene.add(this.ground);\n    console.log(`üåç Ground grid created: size=${size.toFixed(2)}, divisions=${divisions}`);\n  }\n\n  private removeGround() {\n    if (this.ground) {\n      this.scene.remove(this.ground);\n      this.ground = null;\n    }\n  }\n\n  private async loadEnvironmentMap() {\n    try {\n      // Dynamically import EXRLoader\n      // @ts-ignore - example loaders may not have types in the project\n      const { EXRLoader } = await import('three/addons/loaders/EXRLoader.js');\n      const exrLoader = new EXRLoader();\n      // Load from public folder\n      exrLoader.load(\n        '/brown_photostudio_02_1k.exr',\n        (texture: THREE.DataTexture) => {\n          texture.mapping = THREE.EquirectangularReflectionMapping;\n          this.lightingManager.setEnvironmentMap(texture);\n          console.log('‚úÖ Environment map loaded successfully');\n        },\n        undefined,\n        (error: any) => {\n          console.error('‚ùå Failed to load environment map:', error);\n        }\n      );\n    } catch (err) {\n      console.warn('EXRLoader dynamic import failed or not available:', err);\n    }\n  }\n\n  /**\n   * Selection management methods for annotations\n   */\n\n  /**\n   * Selection management methods (delegate to AnnotationManager)\n   */\n}\n"],"names":["DEFAULT_CONFIG","AnnotationManager","scene","config","__publicField","annotations","currentIds","a","id","marker","annotation","geometry","position","THREE","isSelected","ids","additive","camera","canvasHeight","pixelSize","scale","distance","fovRadians","mesh","callback","index","point","material","selectedIds","error","DefaultFileUrlResolver","filePath","context","StaticBaseUrlResolver","baseUrl","cleanPath","FunctionResolver","resolveFn","calculateObjectStats","obj","triangles","vertices","textureSet","child","positionAttribute","matAny","prop","textureDimensions","texture","width","height","size","calculateSceneBoundingBox","objects","sceneBBox","objBBox","getMaxDimension","bbox","calculateCameraDistance","objectSize","fovDegrees","padding","calculateCenteringOffset","center","calculateSceneCenteringOffset","hasValidPosition","roundPosition","decimals","formatStats","stats","formatNumber","n","formatDimension","d","UIControlsBuilder","configs","container","buttonElements","button","baseClasses","positionClasses","directionClass","gapClass","allClasses","c","createButton","builder","createButtonPanel","containerConfig","buttonConfigs","CameraManager","aspect","fov","near","far","frustumSize","initialPosition","initialTarget","info","controls","currentPos","currentTarget","frustumHeight","frustumWidth","target","state","boundingBox","maxDim","direction","newPosition","createCameraManager","calculateFrustumSize","LightingManager","camDir","thetaCam","phiCam","theta","phi","r","x","y","z","offset","horizontalDegrees","verticalDegrees","degToRad","enabled","intensity","envMap","ModelLoader","_a","_b","_c","_d","url","materialOverrides","onProgress","format","response","contentLength","reader","chunks","receivedLength","done","value","percentage","buffer","chunk","object","filename","lower","PLYLoader","materialProps","GLTFLoader","DRACOLoader","resolve","reject","gltf","group","clonedChild","NexusObject","nexusObject","overrides","mat","defaults","path","createModelLoader","ThreePresenter","mount","fileUrlResolver","element","widthPx","heightPx","uiControls","w","h","event","rect","modelObjects","model","intersects","intersectionPoint","coords","v","markerObjects","clickedMarker","clickedAnnotationId","targetPosition","startTarget","endTarget","duration","startTime","animate","elapsed","progress","easeProgress","sceneDesc","preserveCamera","savedCameraPos","savedCameraTarget","m","def","sceneUnits","units","rx","ry","rz","maxAbs","twoPi","env","OrbitControls","ViewportGizmo","err","modelDefs","loadPromises","modelDef","projectId","fullUrl","_e","_f","loaded","total","result","allModels","offsetX","offsetZ","offsetY","idx","translation","pos","cameraDistance","targetY","finalDistance","modelId","rotation","visible","visibility","color","thetaDeg","phiDeg","buttonName","buttonMap","dataURL","link","timestamp","divisions","colorCenterLine","colorGrid","EXRLoader"],"mappings":"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"}